@main.route("/payroll/generate", methods=["POST"])
@jwt_required()
def generate_payroll():
    from flask import jsonify, request
    return generate_and_save_payroll()


@main.route("/payroll/export", methods=["GET"])
@jwt_required()
def payroll_export():
    from app.automation import export_payroll_data
    return export_payroll_data(request.args)



# 1. Generate Payroll
# ----------------------------------------
@main.route("/automation/payroll/generate", methods=["POST"])
@jwt_required()
def generate_and_save_payroll():
    from flask import request, jsonify
    from datetime import datetime
    from app import db
    from app.models import Payroll, Recruiter
    from app.routes import (
        apply_deductions,
        get_hours_worked_with_logs,
        get_hours_worked_between_dates,
        calculate_hours_and_holiday,
        calculate_gross_pay
    )

    data = request.get_json()
    recruiter_id = data.get("recruiter_id")
    month = data.get("month")  # Optional if using custom range
    region = (data.get("region") or "").lower()
    pay_period = data.get("pay_period", "monthly")
    start_date = data.get("start_date")
    end_date = data.get("end_date")

    if not recruiter_id or not region or (not month and not (start_date and end_date)):
        return jsonify({"error": "Missing recruiter_id, region, and either month or custom date range"}), 400

    recruiter = Recruiter.query.get(recruiter_id)
    if not recruiter:
        return jsonify({"error": "Recruiter not found"}), 404

    # Determine date range and hours
    if pay_period == "custom" and start_date and end_date:
        hours_worked, debug_logs = get_hours_worked_between_dates(recruiter_id, start_date, end_date)
        lookup_month = start_date[:7]
        start_dt = datetime.strptime(start_date, "%Y-%m-%d").date()
        end_dt = datetime.strptime(end_date, "%Y-%m-%d").date()
    else:
        try:
            year, mon = map(int, month.split("-"))
        except ValueError:
            return jsonify({"error": "Invalid month format. Use YYYY-MM."}), 400
        hours_worked, debug_logs = get_hours_worked_with_logs(recruiter_id, year, mon)
        lookup_month = month
        start_dt = datetime(year, mon, 1).date()
        end_dt = datetime(year, mon, 28).date()  # You can replace this with last-day-of-month logic

    # Payroll config
    rate = recruiter.hourly_rate or 0
    vacation_percent = float(data.get("vacation_percent", recruiter.vacation_percent or 4.0))
    include_vac = bool(data.get("include_vacation_in_gross", region != "us"))

    # Bonuses / Add-ons
    bonuses = {
        "bonus": float(data.get("bonus", recruiter.bonus or 0)),
        "commission": float(data.get("commission", recruiter.commission or 0)),
        "tip": float(data.get("tip", recruiter.tip or 0)),
        "parental_insurance": float(data.get("parental_insurance", 0)),
        "travel_allowance": float(data.get("travel_allowance", 0)),
        "family_bonus": float(data.get("family_bonus", 0)),
        "tax_credit": float(data.get("tax_credit", 0)),
    }

    # Calculate hours + pay breakdown
    reg_hours, ot_hours, hol_hours, hol_pay = calculate_hours_and_holiday(
        region, recruiter.province or "ON", start_dt, end_dt, rate, hours_worked
    )

    gross, vacation_pay = calculate_gross_pay(
        reg_hours, ot_hours, hol_pay, vacation_percent, rate,
        bonuses, include_vac
    )

    # Create or fetch payroll record
    payroll = Payroll.query.filter_by(
        recruiter_id=recruiter_id,
        month=lookup_month,
        region=region
    ).first()

    if not payroll:
        payroll = Payroll(
            recruiter_id=recruiter_id,
            month=lookup_month,
            region=region
        )

    # Assign computed + provided fields
    payroll.region = region
    payroll.start_date = start_date
    payroll.end_date = end_date
    payroll.rate = rate
    payroll.hours_worked = hours_worked
    payroll.vacation_percent = vacation_percent
    payroll.include_vacation_in_gross = include_vac

    payroll.regular_pay = round(reg_hours * rate, 2)
    payroll.overtime_pay = round(ot_hours * rate * 1.5, 2)
    payroll.holiday_pay = round(hol_pay, 2)
    payroll.vacation_pay = round(vacation_pay, 2)
    payroll.gross_pay = round(gross, 2)

    # Save all bonus/addon fields
    for key, val in bonuses.items():
        setattr(payroll, key, val)

    payroll.deduction = float(data.get("deduction", recruiter.deduction or 0))
    payroll.tax = float(data.get("tax", recruiter.tax or 0))

    # Optional overrides
    for field in ["cpp", "qpp", "ei", "rqap", "fica", "medicare", "retirement"]:
        if field in data:
            setattr(payroll, field, data[field])

    # US region special handling
    if region == "us":
        payroll.fica = 6.2
        payroll.medicare = 1.45
        retirement_pct = recruiter.retirement_percent or 0
        payroll.retirement_amount = round(gross * retirement_pct / 100, 2)

    # Final deduction & net pay logic
    apply_deductions(payroll)

    db.session.add(payroll)
    db.session.commit()

    result = payroll.to_dict()
    result["debug_logs"] = debug_logs
    return jsonify(result), 200


# ----------------------------------------
# 2. Finalize Payroll
# ----------------------------------------
@main.route("/automation/payroll/finalize", methods=["POST"])
@jwt_required()
def finalize_payroll_route():
    data = request.get_json()
    month = data.get("month")
    region = data.get("region")

    if not month or not region:
        return jsonify({"error": "Missing month or region"}), 400

    Payroll.query.filter_by(month=month, region=region).update(
        {Payroll.finalized: True}
    )
    db.session.commit()

    return jsonify({"message": f"✅ Payroll finalized for {month} in {region}."}), 200

# ----------------------------------------
# 3. Override Payroll Fields
# 3. Override Payroll Fields
@main.route("/automation/payroll/override", methods=["POST"])
@jwt_required()
def override_payroll_route():
    from app.routes import apply_deductions
    from app.models import PayrollOverride, Payroll, Recruiter
    from app import db
    from flask import request, jsonify
    from flask_jwt_extended import get_jwt_identity

    user_id = get_jwt_identity()
    data = request.get_json()
    payroll_id = data.get("payroll_id")

    if not payroll_id:
        return jsonify({"error": "Missing payroll_id"}), 400

    payroll = Payroll.query.get(payroll_id)
    if not payroll:
        return jsonify({"error": "Payroll entry not found"}), 404

    changed = False
    for field, new_val in data.items():
        if hasattr(payroll, field) and field != "payroll_id":
            old_val = getattr(payroll, field)
            if old_val != new_val:
                setattr(payroll, field, new_val)
                changed = True
                db.session.add(PayrollOverride(
                    payroll_id = payroll_id,
                    field      = field,
                    old_value  = str(old_val),
                    new_value  = str(new_val),
                    updated_by = user_id
                ))

    if not changed:
        return jsonify({"error": "No valid updates provided"}), 400

    # 🔐 Enforce statutory deductions if US region
    if payroll.region == "us":
        payroll.fica = 6.2
        payroll.medicare = 1.45

        # 💼 Auto-compute 401(k) if recruiter profile exists
        recruiter = Recruiter.query.get(payroll.recruiter_id)
        if recruiter and recruiter.retirement_percent:
            payroll.retirement_amount = round(
                (payroll.gross_pay or 0) * recruiter.retirement_percent / 100, 2
            )

    # 🧮 Recalculate all deductions and net pay
    apply_deductions(payroll)

    db.session.commit()
    return jsonify({"message": f"✅ Payroll {payroll_id} overridden"}), 200

# ----------------------------------------
# 4. Preview Payroll (Single or All)
# ----------------------------------------
@main.route("/automation/payroll/preview", methods=["POST"])
@jwt_required()
def preview_payroll():
    data = request.get_json()
    recruiter_id = data.get("recruiter_id")
    month = data.get("month")
    region = data.get("region")

    if not recruiter_id or not month or not region:
        return jsonify({"error": "Missing recruiter_id, month, or region"}), 400

    try:
        result = run_payroll_logic({
            "recruiter_id": recruiter_id,
            "month": month,
            "region": region
        }, preview=True)

        recruiter_data = next((r for r in result if str(r["recruiter_id"]) == str(recruiter_id)), None)
        if not recruiter_data:
            return jsonify({"error": "Recruiter data not found"}), 404

        return jsonify(recruiter_data)

    except Exception as e:
        print("🚨 Preview error:", str(e))
        return jsonify({"error": "Internal server error"}), 500

# 🛑 MOVE this higher up, before any route using it

def get_hours_worked_between_dates(recruiter_id, start_date, end_date):
    from app.models import ShiftLog
    logs = ShiftLog.query.filter(
        ShiftLog.recruiter_id == recruiter_id,
        ShiftLog.date >= start_date,
        ShiftLog.date <= end_date
    ).all()

    total_hours = sum(log.hours_worked or 0 for log in logs)
    debug = [f"{log.date}: {log.hours_worked}" for log in logs]
    return total_hours, debug

from app.models import ShiftLog
from app.routes import get_hours_worked_between_dates

@main.route("/automation/payroll/export", methods=["GET"])
@jwt_required()
def export_payroll_report():
    from io import BytesIO
    import pandas as pd
    from flask import send_file, request, jsonify, render_template_string
    from xhtml2pdf import pisa
    from app.models import Payroll, CompanyProfile
    from app.routes import apply_deductions

    recruiter_id = request.args.get("recruiter_id")
    month = request.args.get("month")
    region = (request.args.get("region") or "").lower()
    export_format = (request.args.get("format") or "csv").lower()
    selected_cols = request.args.getlist("columns[]")

    if not recruiter_id or not month or not region:
        return jsonify({"error": "Missing recruiter_id, month, or region"}), 400

    payrolls = Payroll.query.filter_by(recruiter_id=recruiter_id, month=month, region=region).all()
    if not payrolls:
        return jsonify({"error": "No payroll data found"}), 404

    for p in payrolls:
        if p.region == "us":
            p.fica = 6.2
            p.medicare = 1.45
            apply_deductions(p)
    db.session.commit()

    def safe(val):
        try:
            return round(float(val or 0), 2)
        except Exception:
            return 0.00

    df = pd.DataFrame([{
        **p.to_dict(),
        "employee_name": p.recruiter.name if p.recruiter else "N/A",
        "gross_pay": safe(p.gross_pay),
        "net_pay": safe(p.net_pay),
        "total_deductions": safe(p.total_deductions),
        "qpp_amount": safe(p.qpp_amount),
        "rqap_amount": safe(p.rqap_amount),
        "cpp_amount": safe(p.cpp_amount),
        "ei_amount": safe(p.ei_amount),
        "fica_amount": safe(p.fica_amount),
        "medicare_amount": safe(p.medicare_amount),
        "federal_tax": safe(p.federal_tax_amount),
        "provincial_tax": safe(p.provincial_tax_amount),
        "state_tax": safe(p.state_tax_amount),
        "include_vacation_in_gross": p.include_vacation_in_gross,
        "vacation_pay": safe(p.vacation_pay),
        "bonus": safe(p.bonus),
        "tip": safe(p.tip),
        "commission": safe(p.commission),
        "medical_insurance": safe(p.medical_insurance),
        "dental_insurance": safe(p.dental_insurance),
        "life_insurance": safe(p.life_insurance),
        "retirement_amount": safe(p.retirement_amount),
        "retirement": safe(p.retirement),
        "retirement_employer": safe(((p.recruiter.retirement_employer_percent or 0) * safe(p.gross_pay) / 100) if p.recruiter else 0),
        "tax_credit": safe(p.tax_credit),
        "travel_allowance": safe(p.travel_allowance),
        "parental_insurance": safe(p.parental_insurance),
        "family_bonus": safe(p.family_bonus),
        "rate": safe(p.rate),
        "hours_worked": safe(p.hours_worked),
        "regular_pay": safe(p.regular_pay),
        "overtime_pay": safe(p.overtime_pay),
        "holiday_pay": safe(p.holiday_pay),
    } for p in payrolls])

    if selected_cols:
        if "include_vacation_in_gross" not in selected_cols:
            selected_cols.append("include_vacation_in_gross")
        df = df[[col for col in selected_cols if col in df.columns]]

    buf = BytesIO()
    filename = f"payroll_{month}.{export_format}"

    if export_format == "pdf":
        company = CompanyProfile.query.first()
        data = df.to_dict(orient="records")
        payroll = payrolls[0]
        start_date = getattr(payroll, "start_date", "")
        end_date = getattr(payroll, "end_date", "")

        html_template = """
        <html><head><style>
        body { font-family: Arial; font-size: 12px; margin: 20px; color: #333; }
        .header, .footer { text-align: center; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ccc; padding: 8px; font-size: 11px; }
        th { background-color: #f0f0f0; }
        .section { page-break-after: always; }
        </style></head><body>

        <div class="header">
          <h2>{{ company.name or "Company Inc." }}</h2>
          <p>{{ company.address or "" }}</p>
          <p>{{ company.phone or "" }} | {{ company.email or "" }}</p>
          <p>{{ company.website or "" }}</p>
          <h3>Payroll Report - {{ month }} ({{ region.upper() }})</h3>
          {% if start_date and end_date %}
            <p>Period: {{ start_date }} to {{ end_date }}</p>
          {% endif %}
        </div>

        {% for row in data %}
        <div class="section">
          <h4>Employee: {{ row.employee_name }}</h4>
          <table>
            <tr><th>Hours Worked</th><td>{{ row.hours_worked }}</td></tr>
            <tr><th>Hourly Rate</th><td>${{ row.rate }}</td></tr>
            <tr><th>Regular Pay</th><td>${{ row.regular_pay }}</td></tr>
            <tr><th>Gross Pay</th><td>${{ row.gross_pay }}</td></tr>
            {% if row.vacation_pay > 0 %}
              <tr><th>Include Vacation In Gross</th><td>{{ 'Yes' if row.include_vacation_in_gross else 'No' }}</td></tr>
            {% endif %}

            {% for field in ["vacation_pay", "bonus", "tip", "commission", "parental_insurance", "travel_allowance", "family_bonus", "tax_credit"] %}
              {% if row.get(field, 0)|float > 0 %}
                <tr><th>{{ field.replace("_", " ").title() }}</th><td>${{ row.get(field) }}</td></tr>
              {% endif %}
            {% endfor %}

            {% if region == "ca" %}
              {% for field in ["federal_tax", "provincial_tax", "cpp_amount", "ei_amount"] %}
                {% if row.get(field, 0)|float > 0 %}
                  <tr><th>{{ field.replace("_", " ").upper() }}</th><td>${{ row.get(field) }}</td></tr>
                {% endif %}
              {% endfor %}
            {% elif region == "qc" %}
              {% for field in ["federal_tax", "provincial_tax", "qpp_amount", "ei_amount", "rqap_amount"] %}
                {% if row.get(field, 0)|float > 0 %}
                  <tr><th>{{ field.replace("_", " ").upper() }}</th><td>${{ row.get(field) }}</td></tr>
                {% endif %}
              {% endfor %}
            {% elif region == "us" %}
              {% for field in ["federal_tax", "state_tax", "fica_amount", "medicare_amount"] %}
                {% if row.get(field, 0)|float > 0 %}
                  <tr><th>{{ field.replace("_", " ").upper() }}</th><td>${{ row.get(field) }}</td></tr>
                {% endif %}
              {% endfor %}
            {% endif %}

            {% for field in ["medical_insurance", "dental_insurance", "life_insurance", "retirement_amount"] %}
              {% if row.get(field, 0)|float > 0 %}
                <tr><th>{{ field.replace("_", " ").title() }}</th><td>${{ row.get(field) }}</td></tr>
              {% endif %}
            {% endfor %}

            {% if row.get("retirement", 0)|float > 0 %}
              <tr><th>401(k) Amount ($)</th><td>${{ row.retirement }}</td></tr>
              <tr><th>Employer 401(k) Match ($)</th><td>${{ row.retirement_employer }}</td></tr>
            {% endif %}

            <tr><th>Total Deductions</th><td>${{ row.total_deductions }}</td></tr>
            <tr><th><strong>Net Pay</strong></th><td><strong>${{ row.net_pay }}</strong></td></tr>
          </table>
        </div>
        {% endfor %}

        </body></html>
        """

        rendered_html = render_template_string(
            html_template, data=data, company=company or {}, month=month,
            region=region, start_date=start_date, end_date=end_date
        )
        if pisa.CreatePDF(rendered_html, dest=buf).err:
            return jsonify({"error": "PDF generation failed"}), 500
        mimetype = "application/pdf"

    elif export_format == "csv":
        df.to_csv(buf, index=False)
        mimetype = "text/csv"

    elif export_format == "xlsx":
        df.to_excel(buf, index=False, engine="openpyxl")
        mimetype = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"

    else:
        return jsonify({"error": "Unsupported format"}), 400

    buf.seek(0)
    return send_file(buf, download_name=filename, as_attachment=True, mimetype=mimetype)


# ----------------------------------------
# 6. Export Payroll Override Audit
# ----------------------------------------
@main.route("/automation/payroll/override-audit", methods=["GET"])
@jwt_required()
def export_override_audit():
    query = request.args
    month = query.get("month")
    region = query.get("region")
    export_format = query.get("format", "csv")

    audits_query = PayrollOverride.query.join(Payroll).filter(Payroll.month == month)
    if region:
        audits_query = audits_query.filter(Payroll.region == region)

    audits = audits_query.all()
    data = [{
        "Recruiter ID": audit.payroll.recruiter_id,
        "Field": audit.field,
        "Old Value": audit.old_value,
        "New Value": audit.new_value,
        "Updated By": audit.updated_by,
        "Timestamp": audit.timestamp.strftime("%Y-%m-%d %H:%M:%S")
    } for audit in audits]

    df = pd.DataFrame(data)
    output = BytesIO()
    filename = f"audits_{month}_{region or 'all'}.{export_format}"

    if export_format == "xlsx":
        with pd.ExcelWriter(output, engine="openpyxl") as writer:
            df.to_excel(writer, index=False)
        mimetype = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    else:
        df.to_csv(output, index=False)
        mimetype = "text/csv"

    output.seek(0)
    return send_file(output, as_attachment=True, download_name=filename, mimetype=mimetype)


from calendar import monthrange
from datetime import datetime
from flask import request, jsonify
from app.models import ShiftLog, Recruiter

def get_hours_worked_with_logs(recruiter_id, year, month):
    start_date = datetime(year, month, 1).date()
    last_day = calendar.monthrange(year, month)[1]
    end_date = datetime(year, month, last_day).date()

    shifts = ShiftLog.query.filter(
        ShiftLog.recruiter_id == recruiter_id,
        ShiftLog.date >= start_date,
        ShiftLog.date <= end_date,
        ShiftLog.clock_in.isnot(None),
        ShiftLog.clock_out.isnot(None)
    ).all()

    total = 0.0
    logs = []
    for s in shifts:
        hours = (s.clock_out - s.clock_in).total_seconds() / 3600
        logs.append(f"{s.date} — {hours:.2f} hrs")
        total += hours

    if not shifts:
        logs.append("⚠️ No completed shifts found for this period.")

    return round(total, 2), logs


@main.route("/payroll/run", methods=["POST"])
@jwt_required()
def run_payroll():
    from datetime import datetime
    from app.models import Recruiter, Payroll
    from app.routes import (
        get_hours_worked_with_logs,
        calculate_hours_and_holiday,
        calculate_gross_pay,
        apply_deductions
    )
    from app import db

    data = request.get_json()
    month = data.get("month")  # format: "YYYY-MM"
    region = data.get("region")
    recruiter_id = data.get("recruiter_id")

    if not month or not region:
        return jsonify({"error": "Month and region are required"}), 400

    try:
        year, mon = map(int, month.split("-"))
        start_date = datetime(year, mon, 1).date()
        end_date = datetime(year, mon, 28).date()  # Replace with monthrange if needed
    except Exception:
        return jsonify({"error": "Invalid month format"}), 400

    # Recruiter filter
    query = Recruiter.query.filter_by(country=region.upper())
    if recruiter_id:
        query = query.filter_by(id=recruiter_id)
    recruiters = query.all()

    results = []

    for recruiter in recruiters:
        hours_worked, debug_logs = get_hours_worked_with_logs(recruiter.id, year, mon)
        rate = recruiter.hourly_rate or 0
        vacation_percent = recruiter.vacation_percent or 4.0
        include_vac = region != "us"

        # Add-ons
        bonuses = {
            "bonus": recruiter.bonus or 0,
            "commission": recruiter.commission or 0,
            "tip": recruiter.tip or 0,
            "parental_insurance": 0,
            "travel_allowance": 0,
            "family_bonus": 0,
            "tax_credit": 0,
        }

        reg_hours, ot_hours, hol_hours, hol_pay = calculate_hours_and_holiday(
            region, recruiter.province or "ON", start_date, end_date, rate, hours_worked
        )

        gross, vacation_pay = calculate_gross_pay(
            reg_hours, ot_hours, hol_pay, vacation_percent, rate,
            bonuses, include_vac
        )

        # Create temp payroll for deduction calc
        payroll = Payroll(
            recruiter_id=recruiter.id,
            month=month,
            region=region,
            rate=rate,
            hours_worked=hours_worked,
            regular_pay=reg_hours * rate,
            overtime_pay=ot_hours * rate * 1.5,
            holiday_pay=hol_pay,
            vacation_percent=vacation_percent,
            vacation_pay=vacation_pay,
            include_vacation_in_gross=include_vac,
            gross_pay=gross,
            **bonuses
        )

        payroll.deduction = recruiter.deduction or 0
        payroll.tax = recruiter.tax or 0

        apply_deductions(payroll)

        results.append({
            "recruiter_id": recruiter.id,
            "name": recruiter.name,
            "month": month,
            "region": region,
            "rate": rate,
            "hours_worked": hours_worked,
            "regular_pay": round(payroll.regular_pay, 2),
            "overtime_pay": round(payroll.overtime_pay, 2),
            "holiday_pay": round(payroll.holiday_pay, 2),
            "vacation_pay": round(payroll.vacation_pay, 2),
            "gross_pay": round(payroll.gross_pay, 2),
            "net_pay": round(payroll.net_pay, 2),
            "total_deductions": round(payroll.total_deductions, 2),
            "bonus": round(payroll.bonus, 2),
            "tip": round(payroll.tip, 2),
            "commission": round(payroll.commission, 2),
            "tax_credit": round(payroll.tax_credit, 2),
            "cpp": round(payroll.cpp_amount or 0, 2),
            "ei": round(payroll.ei_amount or 0, 2),
            "fica": round(payroll.fica_amount or 0, 2),
            "medicare": round(payroll.medicare_amount or 0, 2),
            "debug_shifts": debug_logs
        })

    return jsonify(results), 200



# ----------------------------------------
#  Deduction maths in ONE place
# ----------------------------------------
from app.models import TaxConfig

def apply_brackets(gross, brackets):
    tax = 0
    for b in sorted(brackets, key=lambda x: x.get("from", 0)):
        low = b.get("from", 0)
        high = b.get("to", float("inf"))
        rate = b.get("rate", 0)
        if gross > low:
            taxable = min(gross, high) - low
            tax += taxable * (rate / 100)
    return round(tax, 2)

def cap_deduction(amount, max_amount):
    return min(amount, max_amount)

def apply_deductions(payroll):
    """
    Recalculates all *_amount fields, total_deductions, and net_pay for a Payroll row.
    Applies caps and tax brackets if tax config exists.
    """
    g = payroll.gross_pay or 0
    year = int((payroll.month or "2025-01")[:4])
    
    # Determine region identifier
    if payroll.region == "ca":
        region_key = payroll.province.lower() if payroll.province else "canada_federal"
    elif payroll.region == "us":
        region_key = (payroll.province or "us_federal").lower()

    else:
        region_key = "other"

    config = TaxConfig.query.filter_by(year=year, region=region_key).first()

    # Calculate deductions
    if config:
        # Use rates from tax config
        cpp = round(g * (config.cpp_rate or 0) / 100, 2)
        ei = round(g * (config.ei_rate or 0) / 100, 2)
        fica = round(g * (config.fica_rate or 0) / 100, 2)
        medicare = round(g * (config.medicare_rate or 0) / 100, 2)

        payroll.cpp_amount = cap_deduction(cpp, config.cpp_max)
        payroll.ei_amount = cap_deduction(ei, config.ei_max)
        payroll.fica_amount = cap_deduction(fica, config.fica_max)
        payroll.medicare_amount = medicare  # No cap assumed

        # Tax based on brackets
        payroll.tax_amount = apply_brackets(g, config.brackets)
    else:
        # Fallback to existing % values stored in payroll row
        payroll.cpp_amount = round(g * (payroll.cpp or 0) / 100, 2)
        payroll.ei_amount = round(g * (payroll.ei or 0) / 100, 2)
        payroll.fica_amount = round(g * (payroll.fica or 0) / 100, 2)
        payroll.medicare_amount = round(g * (payroll.medicare or 0) / 100, 2)
        payroll.tax_amount = round(g * (payroll.tax or 0) / 100, 2)

    # Flat values (ensure defaults)
    for field in [
        "vacation_pay", "bonus", "tip", "commission",
        "retirement_amount", "deduction",
        "medical_insurance", "dental_insurance", "life_insurance",
        "tax_credit", "travel_allowance", "parental_insurance", "family_bonus",
        "qpp_amount", "rqap_amount"
    ]:
        setattr(payroll, field, getattr(payroll, field) or 0)

    # Total deductions
    payroll.total_deductions = round(sum([
        payroll.cpp_amount, payroll.qpp_amount, payroll.ei_amount,
        payroll.rqap_amount, payroll.fica_amount, payroll.medicare_amount,
        payroll.tax_amount, payroll.retirement_amount, payroll.deduction,
        payroll.medical_insurance, payroll.dental_insurance, payroll.life_insurance
    ]), 2)

    # Additions (positive items)

    add_vac_to_net = not payroll.include_vacation_in_gross

    additions = sum([
        payroll.bonus, payroll.tip, payroll.commission,
        payroll.tax_credit, payroll.travel_allowance,
        payroll.parental_insurance, payroll.family_bonus,
        payroll.vacation_pay if add_vac_to_net else 0
    ])

    payroll.net_pay = round(g + additions - payroll.total_deductions, 2)




@main.route("/automation/tax/config", methods=["POST"])
@jwt_required()
def save_tax_config():
    data = request.json
    year = data.get("year")
    region = data.get("region")
    brackets = data.get("brackets")

    if not year or not region or not brackets:
        return jsonify({"error": "Missing year, region, or brackets"}), 400

    config = TaxConfig.query.filter_by(year=year, region=region).first()
    if not config:
        config = TaxConfig(year=year, region=region)

    config.brackets = brackets
    db.session.add(config)
    db.session.commit()

    return jsonify({"message": "Tax brackets saved successfully."})


@main.route("/automation/tax/config", methods=["GET"])
@jwt_required()
def get_tax_config():
    year = request.args.get("year")
    region = request.args.get("region")

    if not year or not region:
        return jsonify({"error": "Missing year or region"}), 400

    config = TaxConfig.query.filter_by(year=year, region=region).first()
    if not config:
        return jsonify({"error": "No config found"}), 404

    return jsonify({
        "year": config.year,
        "region": config.region,
        "brackets": config.brackets,
    })


@main.route("/payroll/hours", methods=["POST"])
@jwt_required()
def calculate_hours_from_dates():
    from app.models import ShiftLog
    from datetime import datetime

    data = request.get_json()
    recruiter_id = data.get("recruiter_id")
    start_date_str = data.get("start_date")
    end_date_str = data.get("end_date")

    if not recruiter_id or not start_date_str or not end_date_str:
        return jsonify({"error": "Missing recruiter_id or dates"}), 400

    try:
        start_date = datetime.strptime(start_date_str, "%Y-%m-%d").date()
        end_date = datetime.strptime(end_date_str, "%Y-%m-%d").date()

        shifts = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter_id,
            ShiftLog.date >= start_date,
            ShiftLog.date <= end_date
        ).all()

        total_hours = sum(s.duration_hours or 0 for s in shifts)
        return jsonify({ "hours_worked": round(total_hours, 2) })

    except Exception as e:
        return jsonify({ "error": str(e) }), 500






# --- helpers/payroll -------------------------------------------------
# services/payroll_calc.py  (suggested file)  ────────────────────────────────
from datetime import datetime, date
from typing import Dict
from app.models import Payroll, Recruiter

# 2025 statutory numbers – pull from RegionRules if you store them there
CPP_MAX   = 3_754.45        # employee share
CPP_RATE  = 0.0595
EI_MAX    = 1_129.32
EI_RATE   = 0.0166
BPA_FULL  = 15_705          # Federal BPA 2025

def run_payroll_logic(row: Payroll,
                      recruiter: Recruiter,
                      payload: Dict) -> None:
    """
    Mutates `row` in place so that all numeric columns are populated.
    `payload` is exactly the JSON body you receive from the front-end.
    """

    # --------------------------------------------------------------------- #
    # 1. Inputs (fall back to recruiter defaults)                           #
    # --------------------------------------------------------------------- #
    hours           = float(payload.get("hours_worked"     , row.hours_worked or 0))
    rate            = float(payload.get("rate"             , recruiter.hourly_rate))
    overtime_extra  = float(payload.get("overtime_hours"   , 0))
    bonus           = float(payload.get("bonus"            , 0))
    tip             = float(payload.get("tip"              , 0))
    commission      = float(payload.get("commission"       , 0))
    vac_percent     = float(payload.get("vacation_percent" ,
                                      recruiter.vacation_percent or 4))

    # Province-specific overtime threshold
    ot_threshold = 40 if recruiter.province in {"QC", "MB"} else 44

    # --------------------------------------------------------------------- #
    # 2. Gross Pay                                                          #
    # --------------------------------------------------------------------- #
    regular_hours    = min(hours, ot_threshold)
    row.overtime_hours = max(hours - ot_threshold, 0) + overtime_extra

    regular_pay  = regular_hours       * rate
    overtime_pay = row.overtime_hours  * rate * 1.5

    row.gross_pay = round(
        regular_pay + overtime_pay + bonus + tip + commission,
        2
    )

    # --------------------------------------------------------------------- #
    # 3. Vacation Pay                                                       #
    # --------------------------------------------------------------------- #
    row.vacation_percent = vac_percent
    row.vacation_pay     = round(row.gross_pay * vac_percent / 100, 2)

    # --------------------------------------------------------------------- #
    # 4. CPP & EI (monthly slices, capped)                                  #
    # --------------------------------------------------------------------- #
    row.cpp_amount = round(
        min(row.gross_pay * CPP_RATE, CPP_MAX / 12), 2
    )
    row.ei_amount = round(
        min(row.gross_pay * EI_RATE, EI_MAX / 12), 2
    )

    # --------------------------------------------------------------------- #
    # 5. BPA – prorate for mid-year hire                                    #
    # --------------------------------------------------------------------- #
    month_start = datetime.strptime(row.month + "-01", "%Y-%m-%d").date()
    months_left = 12 - month_start.month + 1

    if recruiter.hire_date and recruiter.hire_date.year == month_start.year:
        months_left = 12 - recruiter.hire_date.month + 1

    prorated_bpa_monthly = (BPA_FULL * months_left / 12) / 12
    row.tax_credit = round(prorated_bpa_monthly, 2)

    taxable_base   = max(row.gross_pay - row.tax_credit, 0)
    row.tax_amount = round(taxable_base * 0.15, 2)        # first-bracket 15 %

    # --------------------------------------------------------------------- #
    # 6. Total deductions & Net pay                                         #
    # --------------------------------------------------------------------- #
    perc_deds  = (row.tax_amount + row.cpp_amount + row.ei_amount +

                  (row.vacation_pay if not row.include_vacation_in_gross else 0) +
                  row.retirement_amount + row.fica_amount + row.medicare_amount)

    fixed_deds = (row.medical_insurance + row.dental_insurance +
                  row.life_insurance + row.rrsp + row.rrsp_employer +
                  row.deduction)

    row.total_deductions = round(perc_deds + fixed_deds, 2)
    row.net_pay          = round(row.gross_pay - row.total_deductions, 2)

    # --------------------------------------------------------------------- #
    # 7. Year-to-Date roll-up                                               #
    # --------------------------------------------------------------------- #
    row.ytd_gross          = (row.ytd_gross or 0) + row.gross_pay
    row.ytd_cpp            = (row.ytd_cpp or 0)   + row.cpp_amount
    row.ytd_ei             = (row.ytd_ei  or 0)   + row.ei_amount
    row.ytd_taxable_income = (row.ytd_taxable_income or 0) + taxable_base


@main.route("/payroll/export/preview", methods=["POST"])
@jwt_required()
def export_payroll_preview():
    from app.automation import run_payroll_logic
    try:
        data = request.get_json()
        if not data.get("month") or not data.get("region"):
            return jsonify({"error": "month and region are required"}), 400

        preview_data = run_payroll_logic(data, preview=True)
        return jsonify({"preview": preview_data}), 200

    except Exception as e:
        return jsonify({"error": f"Export preview failed: {str(e)}"}), 500







@main.route("/automation/tax/config/all", methods=["GET"])
@jwt_required()
def get_all_tax_configs():
    from app.models import TaxConfig
    configs = TaxConfig.query.order_by(TaxConfig.updated_at.desc()).all()
    return jsonify([
        {
            "year": cfg.year,
            "region": cfg.region,
            "brackets": cfg.brackets,
            "updated_at": cfg.updated_at
        }
        for cfg in configs
    ])

@main.route("/automation/tax/config", methods=["DELETE"])
@jwt_required()
def delete_tax_config():
    """
    Delete one or more tax configurations.
    Supports:
      - year & region: delete one
      - bulk: delete multiple using JSON body: { "items": [{ "year": 2024, "region": "qc" }, ...] }
    """
    from app.models import db, TaxConfig

    if request.is_json:
        data = request.get_json()
        items = data.get("items")
        if items and isinstance(items, list):
            deleted = 0
            for item in items:
                year = item.get("year")
                region = item.get("region")
                if year and region:
                    deleted += TaxConfig.query.filter_by(year=year, region=region.lower()).delete()
            db.session.commit()
            return jsonify({"message": f"{deleted} tax config(s) deleted"}), 200

    # Fallback: single delete via query params
    year = request.args.get("year")
    region = request.args.get("region")

    if not year or not region:
        return jsonify({"error": "Missing year or region"}), 400

    deleted = TaxConfig.query.filter_by(year=year, region=region.lower()).delete()
    db.session.commit()
    return jsonify({"message": f"{deleted} tax config(s) deleted"}), 200





@main.route("/payroll/save", methods=["POST"])
@jwt_required()
def save_enterprise_payroll():
    """
    Save or overwrite a recruiter’s payroll for a given month.
    Re‑calculates gross pay, deductions, and net pay on the back‑end so that
    exports and preview always match /payroll/calculate.
    """

    # ------------------------------------------------------------------ imports
    from flask import request, jsonify
    from app import db
    from app.models import (
        Payroll, Recruiter, ShiftLog, PerformanceGoal,
        LeaveRequest, TaxConfig
    )
    from sqlalchemy.exc import SQLAlchemyError
    from datetime import datetime, timedelta
    import holidays

    # If you have extracted bracket_tax to a shared util, import it instead:
    # from app.services.payroll_utils import bracket_tax
    # For now it remains inline (unchanged at the end of the file).

    # ---------------------------------------------------------- 1. INPUT & BASIC
    data         = request.get_json(force=True)
    recruiter_id = data.get("recruiter_id")
    month        = data.get("month")
    region       = data.get("region", "ca").lower()
    pay_freq     = data.get("pay_frequency", "biweekly").lower()

    if not recruiter_id or not month:
        return jsonify({"error": "recruiter_id and month are required"}), 400

    recruiter = Recruiter.query.get(recruiter_id)
    if not recruiter:
        return jsonify({"error": "Recruiter not found"}), 404

    # ------------------------------------------------ 2. PROVINCE / STATE & PAY
    province = data.get("province", recruiter.province or "ON").upper()
    if region == "qc":
        province = "QC"
    elif region == "us":
        province = data.get("state", "CA").upper()

    rate             = float(data.get("rate", recruiter.hourly_rate or 0))
    vacation_percent = recruiter.vacation_percent or 4.0

    # ------------------------------------------ 3. BONUS (attendance & perf.)
    attendance_bonus  = 0
    performance_bonus = 0
    start_date_str    = data.get("start_date")
    end_date_str      = data.get("end_date")

    if start_date_str and end_date_str:
        start_dt = datetime.strptime(start_date_str, "%Y-%m-%d")
        end_dt   = datetime.strptime(end_date_str,   "%Y-%m-%d")

        total_shifts     = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter.id,
            ShiftLog.date.between(start_dt, end_dt)
        ).count()
        completed_shifts = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter.id,
            ShiftLog.status == "completed",
            ShiftLog.date.between(start_dt, end_dt)
        ).count()
        if total_shifts and completed_shifts == total_shifts:
            attendance_bonus = 100

        for goal in PerformanceGoal.query.filter_by(recruiter_id=recruiter.id):
            if goal.progress >= goal.target:
                performance_bonus += 75

    manual_bonus = float(data.get("bonus", 0))
    total_bonus = manual_bonus + attendance_bonus + performance_bonus


    # ---------------------------------------------------- 4. HOURS / VACATION
    worked_hours   = float(data.get("hours_worked", 0))
    overtime_hours = float(data.get("overtime_hours", 0))
    holiday_hours  = 0
    holiday_pay    = 0

    if start_date_str and end_date_str:
        country_code = "CA" if region in ["ca", "qc"] else "US"
        try:
            hol = holidays.country_holidays(country_code,
                                            subdiv=province,
                                            years=[start_dt.year])
        except Exception:
            hol = {}
        for day in (start_dt + timedelta(days=n)
                    for n in range((end_dt - start_dt).days + 1)):
            if day in hol:
                holiday_hours += 8
                holiday_pay   += 8 * rate

    total_hours      = worked_hours + overtime_hours
    ot_threshold     = 40 if region == "us" or province == "QC" else 44
    reg_hours        = min(total_hours, ot_threshold)
    extra_ot_hours   = max(0, total_hours - ot_threshold)

    reg_pay   = reg_hours      * rate
    ot_pay    = extra_ot_hours * rate * 1.5
    base_earnings = reg_pay + ot_pay + holiday_pay
    vac_pay = base_earnings * (vacation_percent / 100)


    # ------------------------------ NEW ❶ flag: include_vacation_in_gross
    include_vacation_in_gross = bool(
        data.get("include_vacation_in_gross", region != "us")
    )

    # -------------------------------- NEW ❷ additional taxable components ----
    tip               = float(data.get("tip", 0))
    commission        = float(data.get("commission", 0))
    parental_ins      = float(data.get("parental_insurance", 0))
    travel_allow      = float(data.get("travel_allowance", 0))
    family_bonus_amt  = float(data.get("family_bonus", 0))
    tax_credit_amt    = float(data.get("tax_credit", 0))

    gross_pay = (
    base_earnings +
    (vac_pay if include_vacation_in_gross else 0) +
    total_bonus +
    tip + commission + parental_ins +
    travel_allow + family_bonus_amt + tax_credit_amt
    )


    # --------------------------------------------------- 5. STATIC DEDUCTIONS
    medical_ins   = float(data.get("medical_insurance", 0))
    dental_ins    = float(data.get("dental_insurance", 0))
    life_ins      = float(data.get("life_insurance", 0))
    retirement_am = float(data.get("retirement_amount", 0))
    other_deduct  = float(data.get("deduction", 0))

    insurance_fixed = (
        medical_ins + dental_ins + life_ins + retirement_am + other_deduct
    )

    # ------------------------------------------------ 6. CONTRIBUTIONS
    CPP_CAP = 3754.45
    QPP_CAP = 4038.42
    EI_CAP  = 1049.12
    SS_CAP  = 168_600.0

    cpp_amt = qpp_amt = ei_amt = fica_amt = medicare_amt = rqap_amt = 0

    if region == "us":
        fica_amt     = min(gross_pay, SS_CAP) * 0.062
        medicare_amt = gross_pay * 0.0145

    elif province == "QC":
        qpp_cfg  = TaxConfig.query.filter_by(
            year=start_dt.year, region="qc_qpp"
        ).first()
        qpp_rate = (
            float(qpp_cfg.brackets[0]["rate"])
            if qpp_cfg and qpp_cfg.brackets
            else 0.059
        )
        qpp_amt  = min(gross_pay * qpp_rate, QPP_CAP)
        ei_amt   = min(gross_pay * 0.0132,   EI_CAP)
        rqap_amt = gross_pay * 0.00767

    else:
        cpp_amt = min(gross_pay * 0.0595, CPP_CAP)
        ei_amt  = min(gross_pay * 0.0166, EI_CAP)

    # ---------------------------------------------------- 7. INCOME TAX
    bpa_divisor   = {"weekly": 52, "biweekly": 26, "monthly": 12}.get(pay_freq, 26)
    BPA_ANNUAL    = 15_000.0
    BPA_PERIOD    = BPA_ANNUAL / bpa_divisor
    taxable_base  = max(0, gross_pay - BPA_PERIOD)

    federal_key   = {
        "ca": "canada_federal",
        "qc": "quebec_federal",
        "us": "us_federal"
    }.get(region)
    local_key = (
        f"{province.lower()}_state" if region == "us" else province.lower()
    )

    fed_cfg = TaxConfig.query.filter_by(
        year=start_dt.year, region=federal_key
    ).first()
    loc_cfg = TaxConfig.query.filter_by(
        year=start_dt.year, region=local_key
    ).first()

    # reused helper (kept local for now)
    def bracket_tax(income, brackets):
        tax = 0
        for br in sorted(brackets or [], key=lambda b: b.get("from", 0)):
            lo, hi, r = (
                float(br.get("from", 0)),
                float(br.get("to", float("inf"))),
                float(br.get("rate", 0)),
            )
            if income > lo:
                tax += (min(income, hi) - lo) * r
        return round(tax, 2)

    federal_tax = bracket_tax(taxable_base, fed_cfg.brackets if fed_cfg else [])
    local_tax   = bracket_tax(taxable_base, loc_cfg.brackets if loc_cfg else [])

    # ------------------------------------------------ 8. TOTAL & NET
    total_deductions = (
        federal_tax + local_tax +
        cpp_amt + qpp_amt + ei_amt +
        fica_amt + medicare_amt + rqap_amt +
        insurance_fixed
    )
    net_pay = gross_pay - total_deductions

    # ------------------------------------------------ 9. SAVE / UPDATE RECORD
    payroll = Payroll.query.filter_by(
        recruiter_id=recruiter_id, month=month, region=region
    ).first()
    if not payroll:
        payroll = Payroll(
            recruiter_id=recruiter_id,
            month=month,
            region=region
        )

    # ------------ core fields
    payroll.region               = region
    payroll.province             = province
    payroll.hours_worked         = worked_hours
    payroll.overtime_hours       = overtime_hours
    payroll.start_date           = start_date_str
    payroll.end_date             = end_date_str
    payroll.notes                = data.get("notes", "")
    payroll.finalized            = bool(data.get("finalized", False))

    # ------------ NEW ❸ flag & extra taxable items
    payroll.include_vacation_in_gross = include_vacation_in_gross
    payroll.tip               = tip
    payroll.commission        = commission
    payroll.parental_insurance= parental_ins
    payroll.travel_allowance  = travel_allow
    payroll.family_bonus      = family_bonus_amt
    payroll.tax_credit        = tax_credit_amt

    # ------------ NEW ❹ persist insurance / retirement / other deduct
    payroll.medical_insurance = medical_ins
    payroll.dental_insurance  = dental_ins
    payroll.life_insurance    = life_ins
    payroll.retirement_amount = retirement_am
    payroll.deduction         = other_deduct

    # ------------ bonuses (split + total)
    payroll.manual_bonus       = manual_bonus
    payroll.attendance_bonus   = attendance_bonus
    payroll.performance_bonus  = performance_bonus
    payroll.bonus = total_bonus

    # ------------ calculated
    payroll.vacation_percent      = vacation_percent
    payroll.vacation_pay          = round(vac_pay, 2)
    payroll.gross_pay             = round(gross_pay, 2)
    payroll.federal_tax_amount    = round(federal_tax, 2)
    payroll.provincial_tax_amount = (
        round(local_tax, 2) if region != "us" else 0
    )
    payroll.state_tax_amount      = (
        round(local_tax, 2) if region == "us" else 0
    )
    payroll.cpp_amount        = round(cpp_amt, 2)
    payroll.qpp_amount        = round(qpp_amt, 2)
    payroll.ei_amount         = round(ei_amt, 2)
    payroll.fica_amount       = round(fica_amt, 2)
    payroll.medicare_amount   = round(medicare_amt, 2)
    payroll.rqap_amount       = round(rqap_amt, 2)
    payroll.total_deductions  = round(total_deductions, 2)
    payroll.net_pay           = round(net_pay, 2)

    # ------------------------------------------------ commit / rollback
    try:
        db.session.add(payroll)
        db.session.commit()
        return jsonify({"message": "Payroll saved successfully!"}), 201
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": "Failed to save payroll", "details": str(e)}), 500




from datetime import datetime, timedelta
import holidays  # ✅ Make sure holidays is imported at the top

# ────────────────────────────────────────────────────────────────────────────────
# Payroll preview endpoint ‑ UPDATED 2025‑05‑02
# ────────────────────────────────────────────────────────────────────────────────
from datetime import datetime, timedelta
import calendar
import holidays

from flask import request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity

from app import db
from app.models import (
    Recruiter, Payroll, ShiftLog, LeaveRequest, TaxConfig
)

# Blueprint instance is assumed to be called `main`
@main.route("/payroll/calculate", methods=["POST"])
@jwt_required()
def calculate_payroll_preview_report():
    """
    Build a payroll preview for the selected period without committing
    anything until the caller confirms (or until month‑end payroll run).
    Returns a 400 for bad input, never a 500 on predictable mistakes.
    """
    try:
        # ------------------------------------------------------------------ #
        # 1. BASICS                                                         #
        # ------------------------------------------------------------------ #
        data           = request.get_json(force=True, silent=True) or {}
        region         = data.get("region", "ca").lower()
        month          = data.get("month", datetime.utcnow().strftime("%Y-%m"))
        start_date_str = data.get("start_date")  # may be None/'' from UI
        end_date_str   = data.get("end_date")
        recruiter_id   = data.get("recruiter_id")
        pay_frequency  = data.get("pay_frequency", "biweekly").lower()
        include_vac    = bool(data.get("include_vacation_in_gross", region != "us"))

        # ---------- Recruiter lookup / auth ---------- #
        if not recruiter_id:
            email = get_jwt_identity()
            recruiter = Recruiter.query.filter_by(email=email).first()
            if recruiter is None:
                return jsonify({"error": "Unauthorized"}), 401
            recruiter_id = recruiter.id
        else:
            recruiter = Recruiter.query.get(recruiter_id)
            if recruiter is None:
                return jsonify({"error": "Recruiter not found"}), 404

        province = (data.get("province") or recruiter.province or "ON").upper()
        if region == "qc":
            province = "QC"
        elif region == "us":
            province = (data.get("state") or "CA").upper()

        rate             = float(data.get("rate", recruiter.hourly_rate or 0))
        vacation_percent = float(data.get("vacation_percent",
                                          recruiter.vacation_percent or 4.0))

        # ------------------------------------------------------------------ #
        # 2. PERIOD RESOLUTION                                              #
        # ------------------------------------------------------------------ #
        # If caller passes both dates → trust them. Otherwise, default to
        # the entire month (YYYY‑MM‑01 through month‑end) so the endpoint
        # still works for legacy clients that only submit "month".
        try:
            if start_date_str and end_date_str:
                start_dt = datetime.strptime(start_date_str, "%Y-%m-%d")
                end_dt   = datetime.strptime(end_date_str,   "%Y-%m-%d")
            else:
                year, mon = map(int, month.split("-"))
                start_dt  = datetime(year, mon, 1)
                last_day  = calendar.monthrange(year, mon)[1]
                end_dt    = datetime(year, mon, last_day)
        except ValueError:
            return jsonify({
                "error": "Bad Request",
                "details": "start_date and end_date must be YYYY-MM-DD"
            }), 400

        # Caller supplied only one of the dates → ask for both.
        if (bool(start_date_str) ^ bool(end_date_str)):
            return jsonify({
                "error": "Bad Request",
                "details": "start_date and end_date must be provided together"
            }), 400

        # ------------------------------------------------------------------ #
        # 3. YEAR‑TO‑DATE ACCUMULATION                                      #
        # ------------------------------------------------------------------ #
        ytd_year  = start_dt.year
        hire_date = recruiter.hire_date or datetime(ytd_year, 1, 1).date()

        ytd_payrolls = (
            Payroll.query.filter_by(recruiter_id=recruiter_id, region=region)
            .filter(Payroll.month < month)
            .filter(Payroll.month.like(f"{ytd_year}-%"))
            .filter(Payroll.start_date >= str(hire_date))
            .all()
        )
        ytd = {
            "gross":           sum(p.gross_pay or 0 for p in ytd_payrolls),
            "cpp":             sum(p.cpp_amount or 0 for p in ytd_payrolls),
            "qpp":             sum(p.qpp_amount or 0 for p in ytd_payrolls),
            "ei":              sum(p.ei_amount  or 0 for p in ytd_payrolls),
            "taxable_income":  sum(p.gross_pay  or 0 for p in ytd_payrolls),
        }

        # ------------------------------------------------------------------ #
        # 4. CONSTANTS / BPA                                                #
        # ------------------------------------------------------------------ #
        BPA_ANNUAL = 15_000.00
        CPP_CAP    = 3_754.45
        QPP_CAP    = 4_038.42
        EI_CAP     = 1_049.12
        SS_CAP     = 168_600.00

        freq_div   = {"weekly": 52, "biweekly": 26, "monthly": 12}.get(
                        pay_frequency, 26)
        BPA_PERIOD = BPA_ANNUAL / freq_div

        # ------------------------------------------------------------------ #
        # 5. HOUR‑BASED PAY                                                 #
        # ------------------------------------------------------------------ #
        shifts = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter_id,
            ShiftLog.clock_in  >= start_dt,
            ShiftLog.clock_out <= end_dt
        ).all()
        worked_hours = sum(s.duration_hours or 0 for s in shifts)

        leaves = LeaveRequest.query.filter(
            LeaveRequest.recruiter_id == recruiter_id,
            LeaveRequest.start_date >= start_dt,
            LeaveRequest.end_date   <= end_dt,
            LeaveRequest.status     == "approved"
        ).all()
        paid_leave_hours = sum(l.override_hours or 0 for l in leaves if l.is_paid_leave)

        # Holiday lookup
        country_code = "CA" if region in ("ca", "qc") else "US"
        try:
            hol = holidays.country_holidays(
                country_code, subdiv=province, years=[start_dt.year]
            )
        except Exception:
            hol = {}

        holiday_hours = holiday_pay = 0
        for day in (
            start_dt + timedelta(days=i)
            for i in range((end_dt - start_dt).days + 1)
        ):
            if day in hol:
                holiday_hours += 8
                holiday_pay   += 8 * rate

        total_hours        = worked_hours + paid_leave_hours
        ot_threshold       = 40 if (region == "us" or province in ("QC", "MB")) else 44
        regular_hours      = min(total_hours, ot_threshold)
        overtime_hours     = max(0, total_hours - ot_threshold)
        regular_pay        = regular_hours  * rate
        overtime_pay       = overtime_hours * rate * 1.5
        vacation_pay       = (regular_pay + overtime_pay + holiday_pay) * (vacation_percent / 100)

        bonuses = {name: float(data.get(name, 0)) for name in (
            "commission", "bonus", "tip",
            "parental_insurance", "travel_allowance",
            "family_bonus", "tax_credit"
        )}

        gross = regular_pay + overtime_pay + holiday_pay
        if include_vac:
            gross += vacation_pay
        gross += sum(bonuses.values())

        # ------------------------------------------------------------------ #
        # 6. FIXED DEDUCTIONS (insurance, misc)                             #
        # ------------------------------------------------------------------ #
        insurance_fixed = sum(float(data.get(f, 0)) for f in (
            "medical_insurance", "dental_insurance",
            "life_insurance", "retirement_amount", "deduction"
        ))

        # ------------------------------------------------------------------ #
        # 7. BPA + TAXABLE INCOME                                           #
        # ------------------------------------------------------------------ #
        bpa_remaining  = max(0, BPA_ANNUAL - ytd["taxable_income"])
        current_bpa    = min(BPA_PERIOD, bpa_remaining)
        taxable_income = max(0, gross - current_bpa)

        # ------------------------------------------------------------------ #
        # 8. CONTRIBUTIONS (CPP/QPP/EI/FICA)                                #
        # ------------------------------------------------------------------ #
        cpp = qpp = ei = fica = medicare = rqap = 0.0
        if region == "us":
            fica     = min(gross, SS_CAP) * 0.062
            medicare = gross * 0.0145
        elif province == "QC":
            qpp_rate = 0.059
            qpp_cfg  = TaxConfig.query.filter_by(
                           year=start_dt.year, region="qc_qpp"
                       ).first()
            if qpp_cfg and qpp_cfg.brackets:
                qpp_rate = float(qpp_cfg.brackets[0].get("rate", qpp_rate))
            qpp  = min(gross * qpp_rate, max(0, QPP_CAP - ytd["qpp"]))
            ei   = min(gross * 0.0132,  max(0, EI_CAP  - ytd["ei"]))
            rqap = gross * 0.00767
        else:  # Canada ex‑QC
            cpp = min(gross * 0.0595, max(0, CPP_CAP - ytd["cpp"]))
            ei  = min(gross * 0.0166, max(0, EI_CAP  - ytd["ei"]))

        # ------------------------------------------------------------------ #
        # 9. TAX TABLES (federal / local)                                   #
        # ------------------------------------------------------------------ #
        fed_region = {
            "ca": "canada_federal",
            "qc": "quebec_federal",
            "us": "us_federal"
        }.get(region)
        loc_region = f"{province.lower()}_state" if region == "us" else province.lower()

        fed_cfg = TaxConfig.query.filter_by(year=start_dt.year,
                                            region=fed_region).first()
        loc_cfg = TaxConfig.query.filter_by(year=start_dt.year,
                                            region=loc_region).first()

        def bracket_tax(income, brackets):
            tax = 0
            for br in sorted(brackets or [], key=lambda b: b.get("from", 0)):
                lo, hi = float(br.get("from", 0)), float(br.get("to", float("inf")))
                rate   = float(br.get("rate", 0))
                if income > lo:
                    tax += (min(income, hi) - lo) * rate
            return round(tax, 2)

        federal_tax = bracket_tax(taxable_income, fed_cfg.brackets if fed_cfg else [])
        local_tax   = bracket_tax(taxable_income, loc_cfg.brackets if loc_cfg else [])

        total_tax = federal_tax + local_tax

        # ------------------------------------------------------------------ #
        # 10. TOTAL DEDUCTIONS / NET PAY                                    #
        # ------------------------------------------------------------------ #
        if region == "us":
            total_deductions = total_tax + fica + medicare + insurance_fixed
        elif province == "QC":
            total_deductions = total_tax + qpp + ei + rqap + insurance_fixed
        else:
            total_deductions = total_tax + cpp + ei + insurance_fixed

        net_pay = gross - total_deductions

        # ------------------------------------------------------------------ #
        # 11. OPTIONAL DB PERSIST                                           #
        # ------------------------------------------------------------------ #
        existing = Payroll.query.filter_by(
            recruiter_id=recruiter.id, month=month, region=region
        ).first()
        if existing is None:
            db.session.add(Payroll(
                recruiter_id = recruiter.id,
                month        = month,
                region       = region,
                start_date   = start_dt.date(),
                end_date     = end_dt.date(),
                rate         = rate,
                hours_worked = total_hours,
                regular_pay  = regular_pay,
                overtime_pay = overtime_pay,
                holiday_pay  = holiday_pay,
                vacation_pay = vacation_pay,
                gross_pay    = gross,
                cpp_amount   = cpp,
                qpp_amount   = qpp,
                ei_amount    = ei,
                fica_amount  = fica,
                medicare_amount = medicare,
                rqap_amount  = rqap,
                federal_tax_amount   = federal_tax,
                provincial_tax_amount = local_tax if region != "us" else 0,
                state_tax_amount      = local_tax if region == "us" else 0,
                total_deductions = total_deductions,
                net_pay         = net_pay,
                bonus           = bonuses["bonus"],
                tip             = bonuses["tip"],
                commission      = bonuses["commission"],
                parental_insurance = bonuses["parental_insurance"],
                travel_allowance   = bonuses["travel_allowance"],
                family_bonus       = bonuses["family_bonus"],
                tax_credit         = bonuses["tax_credit"],
                medical_insurance  = float(data.get("medical_insurance", 0)),
                dental_insurance   = float(data.get("dental_insurance", 0)),
                life_insurance     = float(data.get("life_insurance", 0)),
                retirement_amount  = float(data.get("retirement_amount", 0)),
                deduction          = float(data.get("deduction", 0)),
                include_vacation_in_gross = include_vac,
            ))
            db.session.commit()

        # ------------------------------------------------------------------ #
        # 12. RESPONSE                                                      #
        # ------------------------------------------------------------------ #
        pct = lambda a, b: round(a / b * 100, 2) if b else 0

        return jsonify({
            # hours / earnings
            "regular_hours":   round(regular_hours, 2),
            "overtime_hours":  round(overtime_hours, 2),
            "holiday_hours":   round(holiday_hours, 2),
            "regular_pay":     round(regular_pay, 2),
            "overtime_pay":    round(overtime_pay, 2),
            "holiday_pay":     round(holiday_pay, 2),
            "vacation_pay":    round(vacation_pay, 2),
            "gross_pay":       round(gross, 2),
            "taxable_income":  round(taxable_income, 2),

            # deductions ($)
            "federal_tax_amount":    round(federal_tax, 2),
            "provincial_tax_amount": round(local_tax, 2) if region != "us" else 0,
            "state_tax_amount":      round(local_tax, 2) if region == "us" else 0,
            "cpp_amount":           round(cpp, 2),
            "qpp_amount":           round(qpp, 2),
            "ei_amount":            round(ei, 2),
            "fica_amount":          round(fica, 2),
            "medicare_amount":      round(medicare, 2),
            "rqap_amount":          round(rqap, 2),

            # deductions (% of base)
            "federal_tax_percent": pct(federal_tax, taxable_income),
            "provincial_tax_percent": pct(local_tax, taxable_income) if region != "us" else 0,
            "state_tax_percent":      pct(local_tax, taxable_income) if region == "us" else 0,
            "cpp_percent":      pct(cpp, gross),
            "qpp_percent":      pct(qpp, gross),
            "ei_percent":       pct(ei,  gross),
            "fica_percent":     pct(fica, gross),
            "medicare_percent": pct(medicare, gross),
            "rqap_percent":     pct(rqap, gross),

            # aliases for PayslipModal
            "qpp":       pct(qpp,  gross),
            "state_tax": pct(local_tax, taxable_income) if region == "us" else 0,

            "total_deductions": round(total_deductions, 2),
            "net_pay":          round(net_pay, 2),

            # BPA info
            "flags": {
                "bpa_annual":    BPA_ANNUAL,
                "bpa_remaining": bpa_remaining,
                "bpa_period":    current_bpa,
            }
        }), 200

    # ---------------------------------------------------------------------- #
    # 13. UNEXPECTED ERRORS (should be rare)                                 #
    # ---------------------------------------------------------------------- #
    except Exception as err:
        current_app.logger.error("❌ Payroll calculation failed: %s", err,
                                 exc_info=True)
        return jsonify({
            "error":   "Internal Server Error",
            "details": str(err)
        }), 500


def prepare_recruiter_context(data):
    region = data.get("region", "ca").lower()
    month = data.get("month", datetime.utcnow().strftime("%Y-%m"))
    pay_frequency = data.get("pay_frequency", "biweekly").lower()

    recruiter_id = data.get("recruiter_id")
    if not recruiter_id:
        email = get_jwt_identity()
        recruiter = Recruiter.query.filter_by(email=email).first()
    else:
        recruiter = Recruiter.query.get(recruiter_id)

    if not recruiter:
        raise ValueError("Recruiter not found")

    province = data.get("province", recruiter.province or "ON").upper()
    if region == "qc":
        province = "QC"
    elif region == "us":
        province = data.get("state", "CA").upper()

    return recruiter, region, province, month, pay_frequency


def get_date_range(data):
    start_date = datetime.strptime(data.get("start_date"), "%Y-%m-%d")
    end_date = datetime.strptime(data.get("end_date"), "%Y-%m-%d")
    return start_date, end_date


def calculate_ytd(recruiter_id, region, month, hire_date):
    ytd_year = int(month.split("-")[0])
    ytd_payrolls = (
        Payroll.query.filter_by(recruiter_id=recruiter_id, region=region)
        .filter(Payroll.month < month)
        .filter(Payroll.start_date >= hire_date)
        .all()
    )
    return {
        "gross": sum(p.gross_pay or 0 for p in ytd_payrolls),
        "cpp": sum(p.cpp_amount or 0 for p in ytd_payrolls),
        "qpp": sum(p.qpp_amount or 0 for p in ytd_payrolls),
        "ei": sum(p.ei_amount or 0 for p in ytd_payrolls),
        "taxable_income": sum(p.gross_pay or 0 for p in ytd_payrolls),
    }


def calculate_work_hours(recruiter_id, start_date, end_date):
    shifts = ShiftLog.query.filter(
        ShiftLog.recruiter_id == recruiter_id,
        ShiftLog.clock_in >= start_date,
        ShiftLog.clock_out <= end_date
    ).all()

    worked_hours = sum(s.duration_hours or 0 for s in shifts)

    leaves = LeaveRequest.query.filter(
        LeaveRequest.recruiter_id == recruiter_id,
        LeaveRequest.start_date >= start_date,
        LeaveRequest.end_date <= end_date,
        LeaveRequest.status == "approved"
    ).all()

    paid_leave_hours = sum(l.override_hours or 0 for l in leaves if l.is_paid_leave)
    unpaid_leave_hours = sum(l.override_hours or 0 for l in leaves if not l.is_paid_leave)

    total_hours = worked_hours + paid_leave_hours - unpaid_leave_hours

    return total_hours, worked_hours, paid_leave_hours, unpaid_leave_hours


import holidays
from datetime import timedelta

def calculate_hours_and_holiday(region, province, start_date, end_date, rate, total_hours):
    # Treat MT and QC as 40-hour overtime threshold provinces
    overtime_threshold = 40 if region == "us" or province in ["QC", "MB"] else 44

    regular_hours = min(total_hours, overtime_threshold)
    overtime_hours = max(0, total_hours - overtime_threshold)

    # Determine correct country code
    country_code = "CA" if region in ["ca", "qc"] else "US"
    try:
        hol = holidays.country_holidays(country_code, subdiv=province, years=[start_date.year])
    except Exception:
        hol = {}

    holiday_hours = 0
    holiday_pay = 0
    for day in (start_date + timedelta(days=n) for n in range((end_date - start_date).days + 1)):
        if day in hol:
            holiday_hours += 8
            holiday_pay += 8 * rate

    return regular_hours, overtime_hours, holiday_hours, holiday_pay

def calculate_gross_pay(
    regular_hours,
    overtime_hours,
    holiday_pay,
    vacation_percent,
    rate,
    bonuses,
    include_vacation=True  # new optional flag
):
    regular_pay = regular_hours * rate
    overtime_pay = overtime_hours * rate * 1.5
    vacation_pay = (regular_pay + overtime_pay + holiday_pay) * (vacation_percent / 100)

    gross = regular_pay + overtime_pay + holiday_pay
    if include_vacation:
        gross += vacation_pay

    gross += sum([
        float(bonuses.get(key, 0)) for key in
        ["commission", "bonus", "tip", "parental_insurance", "travel_allowance", "family_bonus", "tax_credit"]
    ])

    return gross, vacation_pay


def calculate_insurance_deductions(data):
    return sum([
        float(data.get(key, 0)) for key in
        ["medical_insurance", "dental_insurance", "life_insurance", "retirement_amount", "deduction"]
    ])


def calculate_deductions(gross, ytd, region, province, data, year, insurance_deductions):
    # Same logic as your previous function, split into federal, local, CPP/QPP, EI etc.
    # If you want, I can write the full ready function too!
    ...
    return {
        "taxable_income": taxable_income,
        "federal_tax_amount": federal_tax_amt,
        "provincial_tax_amount": local_tax_amt,
        "total_tax": total_tax,
        "cpp_amount": cpp_contrib,
        "qpp_amount": qpp_contrib,
        "ei_amount": ei_contrib,
        "fica_amount": fica_contrib,
        "medicare_amount": medicare_contrib,
        "rqap_amount": rqap_contrib,
        "total_deductions": total_deductions,
        "bpa_data": {
            "bpa_annual": BPA_ANNUAL,
            "bpa_remaining": bpa_remaining,
            "bpa_period": current_bpa
        }
    }


def build_payroll_response(
    regular_hours, overtime_hours, holiday_hours,
    regular_pay, overtime_pay, holiday_pay, vacation_pay,
    gross, taxable_income, deductions, net_pay, bpa_data
):
    return {
        "regular_hours": round(regular_hours, 2),
        "overtime_hours": round(overtime_hours, 2),
        "holiday_hours": round(holiday_hours, 2),
        "regular_pay": round(regular_pay, 2),
        "overtime_pay": round(overtime_pay, 2),
        "holiday_pay": round(holiday_pay, 2),
        "vacation_pay": round(vacation_pay, 2),
        "gross_pay": round(gross, 2),
        "taxable_income": round(taxable_income, 2),
        "federal_tax_amount": round(deductions["federal_tax_amount"], 2),
        "provincial_tax_amount": round(deductions["provincial_tax_amount"], 2),
        "cpp_amount": round(deductions["cpp_amount"], 2),
        "qpp_amount": round(deductions["qpp_amount"], 2),
        "ei_amount": round(deductions["ei_amount"], 2),
        "fica_amount": round(deductions["fica_amount"], 2),
        "medicare_amount": round(deductions["medicare_amount"], 2),
        "rqap_amount": round(deductions["rqap_amount"], 2),
        "total_deductions": round(deductions["total_deductions"], 2),
        "net_pay": round(net_pay, 2),
        "flags": bpa_data
    }


def calculate_deductions(gross, ytd, region, province, data, year, insurance_deductions):
    from app.models import TaxConfig

    BPA_ANNUAL = 15000.0
    CPP_CAP = 3754.45
    QPP_CAP = 4038.42
    EI_CAP = 1049.12
    SS_CAP = 168600.0

    # Step 1 - BPA Basic Personal Amount
    pay_frequency = data.get("pay_frequency", "biweekly").lower()
    bpa_divisor = {"weekly": 52, "biweekly": 26, "monthly": 12}.get(pay_frequency, 26)
    BPA_PERIOD = BPA_ANNUAL / bpa_divisor

    bpa_remaining = max(0, BPA_ANNUAL - ytd.get("taxable_income", 0))
    current_bpa = min(BPA_PERIOD, bpa_remaining)

    taxable_income = max(0, gross - current_bpa)

    # Step 2 - Tax configs
    federal_region_key = {
        "ca": "canada_federal",
        "qc": "quebec_federal",
        "us": "us_federal"
    }.get(region, "other")

    local_region_key = f"{province.lower()}_state" if region == "us" else province.lower()

    federal_cfg = TaxConfig.query.filter_by(year=year, region=federal_region_key).first()
    local_cfg = TaxConfig.query.filter_by(year=year, region=local_region_key).first()

    # Step 3 - Tax brackets
    def apply_brackets(income, brackets):
        tax = 0
        for b in sorted(brackets or [], key=lambda x: x.get("from", 0)):
            lo = float(b.get("from", 0))
            hi = float(b.get("to", float("inf")))
            rate = float(b.get("rate", 0))
            if income > lo:
                tax += (min(income, hi) - lo) * (rate / 100)
        return round(tax, 2)

    federal_tax_amt = apply_brackets(taxable_income, federal_cfg.brackets if federal_cfg else [])
    local_tax_amt = apply_brackets(taxable_income, local_cfg.brackets if local_cfg else [])

    # Step 4 - Contribution rates from TaxConfig (fallback defaults if missing)
    cpp_rate = getattr(local_cfg, "cpp_rate", 5.95)
    qpp_rate = getattr(local_cfg, "qpp_rate", 7.0)
    ei_rate = getattr(local_cfg, "ei_rate", 1.32)
    fica_rate = getattr(local_cfg, "fica_rate", 6.2)
    medicare_rate = getattr(local_cfg, "medicare_rate", 1.45)
    rqap_rate = getattr(local_cfg, "rqap_rate", 0.767)

    # Step 5 - Calculate contributions
    cpp_contrib = qpp_contrib = ei_contrib = fica_contrib = medicare_contrib = rqap_contrib = 0

    if region == "us":
        fica_contrib = min(gross, SS_CAP) * (fica_rate / 100)
        medicare_contrib = gross * (medicare_rate / 100)
    elif province == "QC":
        qpp_contrib = min(gross * (qpp_rate / 100), max(0, QPP_CAP - ytd.get("qpp", 0)))
        ei_contrib = min(gross * (ei_rate / 100), max(0, EI_CAP - ytd.get("ei", 0)))
        rqap_contrib = gross * (rqap_rate / 100)
    else:
        cpp_contrib = min(gross * (cpp_rate / 100), max(0, CPP_CAP - ytd.get("cpp", 0)))
        ei_contrib = min(gross * (ei_rate / 100), max(0, EI_CAP - ytd.get("ei", 0)))

    # Step 6 - Total deductions
    if region == "us":
        total_deductions = federal_tax_amt + local_tax_amt + fica_contrib + medicare_contrib + insurance_deductions
    elif province == "QC":
        total_deductions = federal_tax_amt + local_tax_amt + qpp_contrib + ei_contrib + rqap_contrib + insurance_deductions
    else:
        total_deductions = federal_tax_amt + local_tax_amt + cpp_contrib + ei_contrib + insurance_deductions

    return {
        "taxable_income": taxable_income,
        "federal_tax_amount": federal_tax_amt,
        "provincial_tax_amount": local_tax_amt,
        "total_tax": federal_tax_amt + local_tax_amt,
        "cpp_amount": cpp_contrib,
        "qpp_amount": qpp_contrib,
        "ei_amount": ei_contrib,
        "fica_amount": fica_contrib,
        "medicare_amount": medicare_contrib,
        "rqap_amount": rqap_contrib,
        "total_deductions": round(total_deductions, 2),
        "bpa_data": {
            "bpa_annual": BPA_ANNUAL,
            "bpa_remaining": bpa_remaining,
            "bpa_period": current_bpa
        }
    } 

