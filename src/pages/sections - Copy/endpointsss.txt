@main.route("/automation/payroll/export", methods=["GET"]) 
@jwt_required()
def export_payroll_report():
    from io import BytesIO
    import pandas as pd
    from flask import send_file, request, jsonify, render_template_string
    from xhtml2pdf import pisa
    from app.models import Payroll, CompanyProfile
    from app.routes import apply_deductions

    recruiter_id = request.args.get("recruiter_id")
    month = request.args.get("month")
    region = (request.args.get("region") or "").lower()
    start_date = request.args.get("start_date")
    end_date = request.args.get("end_date")

    export_format = (request.args.get("format") or "csv").lower()
    selected_cols = request.args.getlist("columns[]")

    if not recruiter_id or not month or not region:
        return jsonify({"error": "Missing recruiter_id, month, or region"}), 400

    q = Payroll.query.filter_by(recruiter_id=recruiter_id, month=month, region=region)

    if start_date and end_date:
       q = q.filter_by(start_date=start_date, end_date=end_date)

    payrolls = q.all()

    if not payrolls:
        return jsonify({"error": "No payroll data found"}), 404

    for p in payrolls:
        if p.region == "us":
            p.fica = 6.2
            p.medicare = 1.45
            apply_deductions(p)
    db.session.commit()

    def safe(val):
        try:
            return round(float(val or 0), 2)
        except Exception:
            return 0.00

    df = pd.DataFrame([{
        **p.to_dict(),
        "employee_name": p.recruiter.name if p.recruiter else "N/A",
        "gross_pay": safe(p.gross_pay),
        "net_pay": safe(p.net_pay),
        "total_deductions": safe(p.total_deductions),
        "qpp_amount": safe(p.qpp_amount),
        "rqap_amount": safe(p.rqap_amount),
        "cpp_amount": safe(p.cpp_amount),
        "ei_amount": safe(p.ei_amount),
        "fica_amount": safe(p.fica_amount),
        "medicare_amount": safe(p.medicare_amount),
        "federal_tax": safe(p.federal_tax_amount),
        "provincial_tax": safe(p.provincial_tax_amount),
        "state_tax": safe(p.state_tax_amount),
        "Vacation Pay Taxable": p.include_vacation_in_gross,
        "vacation_pay": safe(p.vacation_pay),
        "bonus": safe(p.bonus),
        "tip": safe(p.tip),
        "commission": safe(p.commission),
        "medical_insurance": safe(p.medical_insurance),
        "dental_insurance": safe(p.dental_insurance),
        "life_insurance": safe(p.life_insurance),
        "retirement_amount": safe(p.retirement_amount),
        "retirement": safe(p.retirement),
        "retirement_employer": safe(((p.recruiter.retirement_employer_percent or 0) * safe(p.gross_pay) / 100) if p.recruiter else 0),
        "tax_credit": safe(p.tax_credit),
        "travel_allowance": safe(p.travel_allowance),
        "parental_insurance": safe(p.parental_insurance),
        "family_bonus": safe(p.family_bonus),
        "rate": safe(p.rate),
        "hours_worked": safe(p.hours_worked),
        "regular_pay": safe(p.regular_pay),
        "overtime_pay": safe(p.overtime_pay),
        "holiday_pay": safe(p.holiday_pay),
    } for p in payrolls])

    if selected_cols:
        if "include_vacation_in_gross" not in selected_cols:
            selected_cols.append("include_vacation_in_gross")
        df = df[[col for col in selected_cols if col in df.columns]]

    buf = BytesIO()
    filename = f"payroll_{month}.{export_format}"

    if export_format == "pdf":
        company = CompanyProfile.query.first()
        data = df.to_dict(orient="records")
        payroll = payrolls[0]
        start_date = getattr(payroll, "start_date", "")
        end_date = getattr(payroll, "end_date", "")

        html_template = """
        <html><head><style>
        body { font-family: Arial; font-size: 12px; margin: 20px; color: #333; }
        .header, .footer { text-align: center; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ccc; padding: 8px; font-size: 11px; }
        th { background-color: #f0f0f0; }
        .section { page-break-after: always; }
        </style></head><body>

        <div class="header">
          <h2>{{ company.name or "Company Inc." }}</h2>
          <p>{{ company.address or "" }}</p>
          <p>{{ company.phone or "" }} | {{ company.email or "" }}</p>
          <p>{{ company.website or "" }}</p>
          <h3>Payroll Report - {{ month }} ({{ region.upper() }})</h3>
          {% if start_date and end_date %}
            <p>Period: {{ start_date }} to {{ end_date }}</p>
          {% endif %}
        </div>

        {% for row in data %}
        <div class="section">
          <h4>Employee: {{ row.employee_name }}</h4>
          <table>
            <tr><th>Hours Worked</th><td>{{ row.hours_worked }}</td></tr>
            <tr><th>Hourly Rate</th><td>${{ row.rate }}</td></tr>
            <tr><th>Regular Pay</th><td>${{ row.regular_pay }}</td></tr>
            <tr><th>Gross Pay</th><td>${{ row.gross_pay }}</td></tr>
            {% if row.vacation_pay > 0 %}
              <tr><th>Include Vacation In Gross</th><td>{{ 'Yes' if row.include_vacation_in_gross else 'No' }}</td></tr>
            {% endif %}

            {% for field in ["vacation_pay", "bonus", "tip", "commission", "parental_insurance", "travel_allowance", "family_bonus", "tax_credit"] %}
              {% if row.get(field, 0)|float > 0 %}
                <tr><th>{{ field.replace("_", " ").title() }}</th><td>${{ row.get(field) }}</td></tr>
              {% endif %}
            {% endfor %}

            {% if region == "ca" %}
              {% for field in ["federal_tax", "provincial_tax", "cpp_amount", "ei_amount"] %}
                {% if row.get(field, 0)|float > 0 %}
                  <tr><th>{{ field.replace("_", " ").upper() }}</th><td>${{ row.get(field) }}</td></tr>
                {% endif %}
              {% endfor %}
            {% elif region == "qc" %}
              {% for field in ["federal_tax", "provincial_tax", "qpp_amount", "ei_amount", "rqap_amount"] %}
                {% if row.get(field, 0)|float > 0 %}
                  <tr><th>{{ field.replace("_", " ").upper() }}</th><td>${{ row.get(field) }}</td></tr>
                {% endif %}
              {% endfor %}
            {% elif region == "us" %}
              {% for field in ["federal_tax", "state_tax", "fica_amount", "medicare_amount"] %}
                {% if row.get(field, 0)|float > 0 %}
                  <tr><th>{{ field.replace("_", " ").upper() }}</th><td>${{ row.get(field) }}</td></tr>
                {% endif %}
              {% endfor %}
            {% endif %}

            {% for field in ["medical_insurance", "dental_insurance", "life_insurance", "retirement_amount"] %}
              {% if row.get(field, 0)|float > 0 %}
                <tr><th>{{ field.replace("_", " ").title() }}</th><td>${{ row.get(field) }}</td></tr>
              {% endif %}
            {% endfor %}

            {% if row.get("retirement", 0)|float > 0 %}
              <tr><th>401(k) Amount ($)</th><td>${{ row.retirement }}</td></tr>
              <tr><th>Employer 401(k) Match ($)</th><td>${{ row.retirement_employer }}</td></tr>
            {% endif %}

            <tr><th>Total Deductions</th><td>${{ row.total_deductions }}</td></tr>
            <tr><th><strong>Net Pay</strong></th><td><strong>${{ row.net_pay }}</strong></td></tr>
          </table>
        </div>
        {% endfor %}

        </body></html>
        """

        rendered_html = render_template_string(
            html_template, data=data, company=company or {}, month=month,
            region=region, start_date=start_date, end_date=end_date
        )
        if pisa.CreatePDF(rendered_html, dest=buf).err:
            return jsonify({"error": "PDF generation failed"}), 500
        mimetype = "application/pdf"

    elif export_format == "csv":
        df.to_csv(buf, index=False)
        mimetype = "text/csv"

    elif export_format == "xlsx":
        df.to_excel(buf, index=False, engine="openpyxl")
        mimetype = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"

    else:
        return jsonify({"error": "Unsupported format"}), 400

    buf.seek(0)
    return send_file(buf, download_name=filename, as_attachment=True, mimetype=mimetype)   @main.route("/payroll/save", methods=["POST"])
@jwt_required()
def save_enterprise_payroll():
    """
    Save or overwrite a recruiter‚Äôs payroll for a given month.
    Re‚Äëcalculates gross pay, deductions, and net pay on the back‚Äëend so that
    exports and preview always match /payroll/calculate.
    """

    # ------------------------------------------------------------------ imports
    from flask import request, jsonify
    from app import db
    from app.models import (
        Payroll, Recruiter, ShiftLog, PerformanceGoal,
        LeaveRequest, TaxConfig
    )
    from sqlalchemy.exc import SQLAlchemyError
    from datetime import datetime, timedelta
    import holidays

    # If you have extracted bracket_tax to a shared util, import it instead:
    # from app.services.payroll_utils import bracket_tax
    # For now it remains inline (unchanged at the end of the file).

    # ---------------------------------------------------------- 1. INPUT & BASIC
    data         = request.get_json(force=True)
    recruiter_id = data.get("recruiter_id")
    month        = data.get("month")
    region       = data.get("region", "ca").lower()
    pay_freq     = data.get("pay_frequency", "biweekly").lower()

    if not recruiter_id or not month:
        return jsonify({"error": "recruiter_id and month are required"}), 400

    recruiter = Recruiter.query.get(recruiter_id)
    if not recruiter:
        return jsonify({"error": "Recruiter not found"}), 404

    # ------------------------------------------------ 2. PROVINCE / STATE & PAY
    province = data.get("province", recruiter.province or "ON").upper()
    if region == "qc":
        province = "QC"
    elif region == "us":
        province = data.get("state", "CA").upper()

    rate             = float(data.get("rate", recruiter.hourly_rate or 0))
    vacation_percent = recruiter.vacation_percent or 4.0

    # ------------------------------------------ 3. BONUS (attendance & perf.)
    attendance_bonus  = 0
    performance_bonus = 0
    start_date_str    = data.get("start_date")
    end_date_str      = data.get("end_date")

    if start_date_str and end_date_str:
        start_dt = datetime.strptime(start_date_str, "%Y-%m-%d")
        end_dt   = datetime.strptime(end_date_str,   "%Y-%m-%d")

        total_shifts     = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter.id,
            ShiftLog.date.between(start_dt, end_dt)
        ).count()
        completed_shifts = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter.id,
            ShiftLog.status == "completed",
            ShiftLog.date.between(start_dt, end_dt)
        ).count()
        if total_shifts and completed_shifts == total_shifts:
            attendance_bonus = 100

        for goal in PerformanceGoal.query.filter_by(recruiter_id=recruiter.id):
            if goal.progress >= goal.target:
                performance_bonus += 75

    manual_bonus = float(data.get("bonus", 0))
    total_bonus = manual_bonus + attendance_bonus + performance_bonus


    # ---------------------------------------------------- 4. HOURS / VACATION
    worked_hours   = float(data.get("hours_worked", 0))
    overtime_hours = float(data.get("overtime_hours", 0))
    holiday_hours  = 0
    holiday_pay    = 0

    if start_date_str and end_date_str:
        country_code = "CA" if region in ["ca", "qc"] else "US"
        try:
            hol = holidays.country_holidays(country_code,
                                            subdiv=province,
                                            years=[start_dt.year])
        except Exception:
            hol = {}
        for day in (start_dt + timedelta(days=n)
                    for n in range((end_dt - start_dt).days + 1)):
            if day in hol:
                holiday_hours += 8
                holiday_pay   += 8 * rate

    total_hours      = worked_hours + overtime_hours
    ot_threshold     = 40 if region == "us" or province == "QC" else 44
    reg_hours        = min(total_hours, ot_threshold)
    extra_ot_hours   = max(0, total_hours - ot_threshold)

    reg_pay   = reg_hours      * rate
    ot_pay    = extra_ot_hours * rate * 1.5
    base_earnings = reg_pay + ot_pay + holiday_pay
    vac_pay = base_earnings * (vacation_percent / 100)


    # ------------------------------ NEW ‚ù∂ flag: include_vacation_in_gross
    include_vacation_in_gross = bool(
        data.get("include_vacation_in_gross", region != "us")
    )

    # -------------------------------- NEW ‚ù∑ additional taxable components ----
    tip               = float(data.get("tip", 0))
    commission        = float(data.get("commission", 0))
    parental_ins      = float(data.get("parental_insurance", 0))
    travel_allow      = float(data.get("travel_allowance", 0))
    family_bonus_amt  = float(data.get("family_bonus", 0))
    tax_credit_amt    = float(data.get("tax_credit", 0))

    gross_pay = (
    base_earnings +
    (vac_pay if include_vacation_in_gross else 0) +
    total_bonus +
    tip + commission + parental_ins +
    travel_allow + family_bonus_amt + tax_credit_amt
    )


    # --------------------------------------------------- 5. STATIC DEDUCTIONS
    medical_ins   = float(data.get("medical_insurance", 0))
    dental_ins    = float(data.get("dental_insurance", 0))
    life_ins      = float(data.get("life_insurance", 0))
    retirement_am = float(data.get("retirement_amount", 0))
    other_deduct  = float(data.get("deduction", 0))

    insurance_fixed = (
        medical_ins + dental_ins + life_ins + retirement_am + other_deduct
    )

    # ------------------------------------------------ 6. CONTRIBUTIONS
    CPP_CAP = 3754.45
    QPP_CAP = 4038.42
    EI_CAP  = 1049.12
    SS_CAP  = 168_600.0

    cpp_amt = qpp_amt = ei_amt = fica_amt = medicare_amt = rqap_amt = 0

    if region == "us":
        fica_amt     = min(gross_pay, SS_CAP) * 0.062
        medicare_amt = gross_pay * 0.0145

    elif province == "QC":
        qpp_cfg  = TaxConfig.query.filter_by(
            year=start_dt.year, region="qc_qpp"
        ).first()
        qpp_rate = (
            float(qpp_cfg.brackets[0]["rate"])
            if qpp_cfg and qpp_cfg.brackets
            else 0.059
        )
        qpp_amt  = min(gross_pay * qpp_rate, QPP_CAP)
        ei_amt   = min(gross_pay * 0.0132,   EI_CAP)
        rqap_amt = gross_pay * 0.00767

    else:
        cpp_amt = min(gross_pay * 0.0595, CPP_CAP)
        ei_amt  = min(gross_pay * 0.0166, EI_CAP)

    # ---------------------------------------------------- 7. INCOME TAX
    bpa_divisor   = {"weekly": 52, "biweekly": 26, "monthly": 12}.get(pay_freq, 26)
    BPA_ANNUAL    = 15_000.0
    BPA_PERIOD    = BPA_ANNUAL / bpa_divisor
    taxable_base  = max(0, gross_pay - BPA_PERIOD)

    federal_key   = {
        "ca": "canada_federal",
        "qc": "quebec_federal",
        "us": "us_federal"
    }.get(region)
    local_key = (
        f"{province.lower()}_state" if region == "us" else province.lower()
    )

    fed_cfg = TaxConfig.query.filter_by(
        year=start_dt.year, region=federal_key
    ).first()
    loc_cfg = TaxConfig.query.filter_by(
        year=start_dt.year, region=local_key
    ).first()

    # reused helper (kept local for now)
    def bracket_tax(income, brackets):
        tax = 0
        for br in sorted(brackets or [], key=lambda b: b.get("from", 0)):
            lo, hi, r = (
                float(br.get("from", 0)),
                float(br.get("to", float("inf"))),
                float(br.get("rate", 0)),
            )
            if income > lo:
                tax += (min(income, hi) - lo) * r
        return round(tax, 2)

    federal_tax = bracket_tax(taxable_base, fed_cfg.brackets if fed_cfg else [])
    local_tax   = bracket_tax(taxable_base, loc_cfg.brackets if loc_cfg else [])

    # ------------------------------------------------ 8. TOTAL & NET
    total_deductions = (
        federal_tax + local_tax +
        cpp_amt + qpp_amt + ei_amt +
        fica_amt + medicare_amt + rqap_amt +
        insurance_fixed
    )
    net_pay = gross_pay - total_deductions

    # ------------------------------------------------ 9. SAVE / UPDATE RECORD
    payroll = Payroll.query.filter_by(
        recruiter_id=recruiter_id,
    month=month,
    region=region,
    start_date=start_date_str,
    end_date=end_date_str
    ).first()
    if not payroll:
        payroll = Payroll(
            recruiter_id=recruiter_id,
            month=month,
            region=region
        )

    # ------------ core fields
    payroll.region               = region
    payroll.province             = province
    payroll.hours_worked         = worked_hours
    payroll.overtime_hours       = overtime_hours
    payroll.start_date           = start_date_str
    payroll.end_date             = end_date_str
    payroll.notes                = data.get("notes", "")
    payroll.finalized            = bool(data.get("finalized", False))

    # ------------ NEW ‚ù∏ flag & extra taxable items
    payroll.include_vacation_in_gross = include_vacation_in_gross
    payroll.tip               = tip
    payroll.commission        = commission
    payroll.parental_insurance= parental_ins
    payroll.travel_allowance  = travel_allow
    payroll.family_bonus      = family_bonus_amt
    payroll.tax_credit        = tax_credit_amt

    # ------------ NEW ‚ùπ persist insurance / retirement / other deduct
    payroll.medical_insurance = medical_ins
    payroll.dental_insurance  = dental_ins
    payroll.life_insurance    = life_ins
    payroll.retirement_amount = retirement_am
    payroll.deduction         = other_deduct

    # ------------ bonuses (split + total)
    payroll.manual_bonus       = manual_bonus
    payroll.attendance_bonus   = attendance_bonus
    payroll.performance_bonus  = performance_bonus
    payroll.bonus = total_bonus

    # ------------ calculated
    payroll.vacation_percent      = vacation_percent
    payroll.vacation_pay          = round(vac_pay, 2)
    payroll.gross_pay             = round(gross_pay, 2)
    payroll.federal_tax_amount    = round(federal_tax, 2)
    payroll.provincial_tax_amount = (
        round(local_tax, 2) if region != "us" else 0
    )
    payroll.state_tax_amount      = (
        round(local_tax, 2) if region == "us" else 0
    )
    payroll.cpp_amount        = round(cpp_amt, 2)
    payroll.qpp_amount        = round(qpp_amt, 2)
    payroll.ei_amount         = round(ei_amt, 2)
    payroll.fica_amount       = round(fica_amt, 2)
    payroll.medicare_amount   = round(medicare_amt, 2)
    payroll.rqap_amount       = round(rqap_amt, 2)
    payroll.total_deductions  = round(total_deductions, 2)
    payroll.net_pay           = round(net_pay, 2)

    # ------------------------------------------------ commit / rollback
    try:
        db.session.add(payroll)
        db.session.commit()
        return jsonify({"message": "Payroll saved successfully!"}), 201
    except SQLAlchemyError as e:
        db.session.rollback()
        return jsonify({"error": "Failed to save payroll", "details": str(e)}), 500




from datetime import datetime, timedelta
import holidays  # ‚úÖ Make sure holidays is imported at the top

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Payroll preview endpoint ‚Äë UPDATED 2025‚Äë05‚Äë02
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
from datetime import datetime, timedelta
import calendar
import holidays

from flask import request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity

from app import db
from app.models import (
    Recruiter, Payroll, ShiftLog, LeaveRequest, TaxConfig
)

# Blueprint instance is assumed to be called `main`
@main.route("/payroll/calculate", methods=["POST"])
@jwt_required()
def calculate_payroll_preview_report():
    """
    Build a payroll preview for the selected period without committing
    anything until the caller confirms (or until month‚Äëend payroll run).
    Returns a 400 for bad input, never a 500 on predictable mistakes.
    """
    try:
        # ------------------------------------------------------------------ #
        # 1. BASICS                                                         #
        # ------------------------------------------------------------------ #
        data           = request.get_json(force=True, silent=True) or {}
        region         = data.get("region", "ca").lower()
        month          = data.get("month", datetime.utcnow().strftime("%Y-%m"))
        start_date_str = data.get("start_date")  # may be None/'' from UI
        end_date_str   = data.get("end_date")
        recruiter_id   = data.get("recruiter_id")
        pay_frequency  = data.get("pay_frequency", "biweekly").lower()
        include_vac    = bool(data.get("include_vacation_in_gross", region != "us"))

        # ---------- Recruiter lookup / auth ---------- #
        if not recruiter_id:
            email = get_jwt_identity()
            recruiter = Recruiter.query.filter_by(email=email).first()
            if recruiter is None:
                return jsonify({"error": "Unauthorized"}), 401
            recruiter_id = recruiter.id
        else:
            recruiter = Recruiter.query.get(recruiter_id)
            if recruiter is None:
                return jsonify({"error": "Recruiter not found"}), 404

        province = (data.get("province") or recruiter.province or "ON").upper()
        if region == "qc":
            province = "QC"
        elif region == "us":
            province = (data.get("state") or "CA").upper()

        rate             = float(data.get("rate", recruiter.hourly_rate or 0))
        vacation_percent = float(data.get("vacation_percent",
                                          recruiter.vacation_percent or 4.0))

        # ------------------------------------------------------------------ #
        # 2. PERIOD RESOLUTION                                              #
        # ------------------------------------------------------------------ #
        # If caller passes both dates ‚Üí trust them. Otherwise, default to
        # the entire month (YYYY‚ÄëMM‚Äë01 through month‚Äëend) so the endpoint
        # still works for legacy clients that only submit "month".
        try:
            if start_date_str and end_date_str:
                start_dt = datetime.strptime(start_date_str, "%Y-%m-%d")
                end_dt   = datetime.strptime(end_date_str,   "%Y-%m-%d")
            else:
                year, mon = map(int, month.split("-"))
                start_dt  = datetime(year, mon, 1)
                last_day  = calendar.monthrange(year, mon)[1]
                end_dt    = datetime(year, mon, last_day)
        except ValueError:
            return jsonify({
                "error": "Bad Request",
                "details": "start_date and end_date must be YYYY-MM-DD"
            }), 400

        # Caller supplied only one of the dates ‚Üí ask for both.
        if (bool(start_date_str) ^ bool(end_date_str)):
            return jsonify({
                "error": "Bad Request",
                "details": "start_date and end_date must be provided together"
            }), 400

        # ------------------------------------------------------------------ #
        # 3. YEAR‚ÄëTO‚ÄëDATE ACCUMULATION                                      #
        # ------------------------------------------------------------------ #
        ytd_year  = start_dt.year
        hire_date = recruiter.hire_date or datetime(ytd_year, 1, 1).date()

        ytd_payrolls = (
            Payroll.query.filter_by(recruiter_id=recruiter_id, region=region)
            .filter(Payroll.month < month)
            .filter(Payroll.month.like(f"{ytd_year}-%"))
            .filter(Payroll.start_date >= str(hire_date))
            .all()
        )
        ytd = {
            "gross":           sum(p.gross_pay or 0 for p in ytd_payrolls),
            "cpp":             sum(p.cpp_amount or 0 for p in ytd_payrolls),
            "qpp":             sum(p.qpp_amount or 0 for p in ytd_payrolls),
            "ei":              sum(p.ei_amount  or 0 for p in ytd_payrolls),
            "taxable_income":  sum(p.gross_pay  or 0 for p in ytd_payrolls),
        }

        # ------------------------------------------------------------------ #
        # 4. CONSTANTS / BPA                                                #
        # ------------------------------------------------------------------ #
        BPA_ANNUAL = 15_000.00
        CPP_CAP    = 3_754.45
        QPP_CAP    = 4_038.42
        EI_CAP     = 1_049.12
        SS_CAP     = 168_600.00

        freq_div   = {"weekly": 52, "biweekly": 26, "monthly": 12}.get(
                        pay_frequency, 26)
        BPA_PERIOD = BPA_ANNUAL / freq_div

        # ------------------------------------------------------------------ #
        # 5. HOUR‚ÄëBASED PAY                                                 #
        # ------------------------------------------------------------------ #
        shifts = ShiftLog.query.filter(
            ShiftLog.recruiter_id == recruiter_id,
            ShiftLog.clock_in  >= start_dt,
            ShiftLog.clock_out <= end_dt
        ).all()
        worked_hours = sum(s.duration_hours or 0 for s in shifts)

        leaves = LeaveRequest.query.filter(
            LeaveRequest.recruiter_id == recruiter_id,
            LeaveRequest.start_date >= start_dt,
            LeaveRequest.end_date   <= end_dt,
            LeaveRequest.status     == "approved"
        ).all()
        paid_leave_hours = sum(l.override_hours or 0 for l in leaves if l.is_paid_leave)

        # Holiday lookup
        country_code = "CA" if region in ("ca", "qc") else "US"
        try:
            hol = holidays.country_holidays(
                country_code, subdiv=province, years=[start_dt.year]
            )
        except Exception:
            hol = {}

        holiday_hours = holiday_pay = 0
        for day in (
            start_dt + timedelta(days=i)
            for i in range((end_dt - start_dt).days + 1)
        ):
            if day in hol:
                holiday_hours += 8
                holiday_pay   += 8 * rate

        total_hours        = worked_hours + paid_leave_hours
        ot_threshold       = 40 if (region == "us" or province in ("QC", "MB")) else 44
        regular_hours      = min(total_hours, ot_threshold)
        overtime_hours     = max(0, total_hours - ot_threshold)
        regular_pay        = regular_hours  * rate
        overtime_pay       = overtime_hours * rate * 1.5
        vacation_pay       = (regular_pay + overtime_pay + holiday_pay) * (vacation_percent / 100)

        bonuses = {name: float(data.get(name, 0)) for name in (
            "commission", "bonus", "tip",
            "parental_insurance", "travel_allowance",
            "family_bonus", "tax_credit"
        )}

        gross = regular_pay + overtime_pay + holiday_pay
        if include_vac:
            gross += vacation_pay
        gross += sum(bonuses.values())

        # ------------------------------------------------------------------ #
        # 6. FIXED DEDUCTIONS (insurance, misc)                             #
        # ------------------------------------------------------------------ #
        insurance_fixed = sum(float(data.get(f, 0)) for f in (
            "medical_insurance", "dental_insurance",
            "life_insurance", "retirement_amount", "deduction"
        ))

        # ------------------------------------------------------------------ #
        # 7. BPA + TAXABLE INCOME                                           #
        # ------------------------------------------------------------------ #
        bpa_remaining  = max(0, BPA_ANNUAL - ytd["taxable_income"])
        current_bpa    = min(BPA_PERIOD, bpa_remaining)
        taxable_income = max(0, gross - current_bpa)

        # ------------------------------------------------------------------ #
        # 8. CONTRIBUTIONS (CPP/QPP/EI/FICA)                                #
        # ------------------------------------------------------------------ #
        cpp = qpp = ei = fica = medicare = rqap = 0.0
        if region == "us":
            fica     = min(gross, SS_CAP) * 0.062
            medicare = gross * 0.0145
        elif province == "QC":
            qpp_rate = 0.059
            qpp_cfg  = TaxConfig.query.filter_by(
                           year=start_dt.year, region="qc_qpp"
                       ).first()
            if qpp_cfg and qpp_cfg.brackets:
                qpp_rate = float(qpp_cfg.brackets[0].get("rate", qpp_rate))
            qpp  = min(gross * qpp_rate, max(0, QPP_CAP - ytd["qpp"]))
            ei   = min(gross * 0.0132,  max(0, EI_CAP  - ytd["ei"]))
            rqap = gross * 0.00767
        else:  # Canada ex‚ÄëQC
            cpp = min(gross * 0.0595, max(0, CPP_CAP - ytd["cpp"]))
            ei  = min(gross * 0.0166, max(0, EI_CAP  - ytd["ei"]))

        # ------------------------------------------------------------------ #
        # 9. TAX TABLES (federal / local)                                   #
        # ------------------------------------------------------------------ #
        fed_region = {
            "ca": "canada_federal",
            "qc": "quebec_federal",
            "us": "us_federal"
        }.get(region)
        loc_region = f"{province.lower()}_state" if region == "us" else province.lower()

        fed_cfg = TaxConfig.query.filter_by(year=start_dt.year,
                                            region=fed_region).first()
        loc_cfg = TaxConfig.query.filter_by(year=start_dt.year,
                                            region=loc_region).first()

        def bracket_tax(income, brackets):
            tax = 0
            for br in sorted(brackets or [], key=lambda b: b.get("from", 0)):
                lo, hi = float(br.get("from", 0)), float(br.get("to", float("inf")))
                rate   = float(br.get("rate", 0))
                if income > lo:
                    tax += (min(income, hi) - lo) * rate
            return round(tax, 2)

        federal_tax = bracket_tax(taxable_income, fed_cfg.brackets if fed_cfg else [])
        local_tax   = bracket_tax(taxable_income, loc_cfg.brackets if loc_cfg else [])

        total_tax = federal_tax + local_tax

        # ------------------------------------------------------------------ #
        # 10. TOTAL DEDUCTIONS / NET PAY                                    #
        # ------------------------------------------------------------------ #
        if region == "us":
            total_deductions = total_tax + fica + medicare + insurance_fixed
        elif province == "QC":
            total_deductions = total_tax + qpp + ei + rqap + insurance_fixed
        else:
            total_deductions = total_tax + cpp + ei + insurance_fixed

        net_pay = gross - total_deductions

        # ------------------------------------------------------------------ #
        # 11. OPTIONAL DB PERSIST                                           #
        # ------------------------------------------------------------------ #
        existing = Payroll.query.filter_by(
            recruiter_id=recruiter.id, month=month, region=region
        ).first()
        if existing is None:
            db.session.add(Payroll(
                recruiter_id = recruiter.id,
                month        = month,
                region       = region,
                start_date   = start_dt.date(),
                end_date     = end_dt.date(),
                rate         = rate,
                hours_worked = total_hours,
                regular_pay  = regular_pay,
                overtime_pay = overtime_pay,
                holiday_pay  = holiday_pay,
                vacation_pay = vacation_pay,
                gross_pay    = gross,
                cpp_amount   = cpp,
                qpp_amount   = qpp,
                ei_amount    = ei,
                fica_amount  = fica,
                medicare_amount = medicare,
                rqap_amount  = rqap,
                federal_tax_amount   = federal_tax,
                provincial_tax_amount = local_tax if region != "us" else 0,
                state_tax_amount      = local_tax if region == "us" else 0,
                total_deductions = total_deductions,
                net_pay         = net_pay,
                bonus           = bonuses["bonus"],
                tip             = bonuses["tip"],
                commission      = bonuses["commission"],
                parental_insurance = bonuses["parental_insurance"],
                travel_allowance   = bonuses["travel_allowance"],
                family_bonus       = bonuses["family_bonus"],
                tax_credit         = bonuses["tax_credit"],
                medical_insurance  = float(data.get("medical_insurance", 0)),
                dental_insurance   = float(data.get("dental_insurance", 0)),
                life_insurance     = float(data.get("life_insurance", 0)),
                retirement_amount  = float(data.get("retirement_amount", 0)),
                deduction          = float(data.get("deduction", 0)),
                include_vacation_in_gross = include_vac,
            ))
            db.session.commit()

        # ------------------------------------------------------------------ #
        # 12. RESPONSE                                                      #
        # ------------------------------------------------------------------ #
        pct = lambda a, b: round(a / b * 100, 2) if b else 0

        return jsonify({
            # hours / earnings
            "regular_hours":   round(regular_hours, 2),
            "overtime_hours":  round(overtime_hours, 2),
            "holiday_hours":   round(holiday_hours, 2),
            "regular_pay":     round(regular_pay, 2),
            "overtime_pay":    round(overtime_pay, 2),
            "holiday_pay":     round(holiday_pay, 2),
            "vacation_pay":    round(vacation_pay, 2),
            "gross_pay":       round(gross, 2),
            "taxable_income":  round(taxable_income, 2),

            # deductions ($)
            "federal_tax_amount":    round(federal_tax, 2),
            "provincial_tax_amount": round(local_tax, 2) if region != "us" else 0,
            "state_tax_amount":      round(local_tax, 2) if region == "us" else 0,
            "cpp_amount":           round(cpp, 2),
            "qpp_amount":           round(qpp, 2),
            "ei_amount":            round(ei, 2),
            "fica_amount":          round(fica, 2),
            "medicare_amount":      round(medicare, 2),
            "rqap_amount":          round(rqap, 2),

            # deductions (% of base)
            "federal_tax_percent": pct(federal_tax, taxable_income),
            "provincial_tax_percent": pct(local_tax, taxable_income) if region != "us" else 0,
            "state_tax_percent":      pct(local_tax, taxable_income) if region == "us" else 0,
            "cpp_percent":      pct(cpp, gross),
            "qpp_percent":      pct(qpp, gross),
            "ei_percent":       pct(ei,  gross),
            "fica_percent":     pct(fica, gross),
            "medicare_percent": pct(medicare, gross),
            "rqap_percent":     pct(rqap, gross),

            # aliases for PayslipModal
            "qpp":       pct(qpp,  gross),
            "state_tax": pct(local_tax, taxable_income) if region == "us" else 0,

            "total_deductions": round(total_deductions, 2),
            "net_pay":          round(net_pay, 2),

            # BPA info
            "flags": {
                "bpa_annual":    BPA_ANNUAL,
                "bpa_remaining": bpa_remaining,
                "bpa_period":    current_bpa,
            }
        }), 200

    # ---------------------------------------------------------------------- #
    # 13. UNEXPECTED ERRORS (should be rare)                                 #
    # ---------------------------------------------------------------------- #
    except Exception as err:
        current_app.logger.error("‚ùå Payroll calculation failed: %s", err,
                                 exc_info=True)
        return jsonify({
            "error":   "Internal Server Error",
            "details": str(err)
        }), 500


def prepare_recruiter_context(data):
    region = data.get("region", "ca").lower()
    month = data.get("month", datetime.utcnow().strftime("%Y-%m"))
    pay_frequency = data.get("pay_frequency", "biweekly").lower()

    recruiter_id = data.get("recruiter_id")
    if not recruiter_id:
        email = get_jwt_identity()
        recruiter = Recruiter.query.filter_by(email=email).first()
    else:
        recruiter = Recruiter.query.get(recruiter_id)

    if not recruiter:
        raise ValueError("Recruiter not found")

    province = data.get("province", recruiter.province or "ON").upper()
    if region == "qc":
        province = "QC"
    elif region == "us":
        province = data.get("state", "CA").upper()

    return recruiter, region, province, month, pay_frequency


def get_date_range(data):
    start_date = datetime.strptime(data.get("start_date"), "%Y-%m-%d")
    end_date = datetime.strptime(data.get("end_date"), "%Y-%m-%d")
    return start_date, end_date


def calculate_ytd(recruiter_id, region, month, hire_date):
    ytd_year = int(month.split("-")[0])
    ytd_payrolls = (
        Payroll.query.filter_by(recruiter_id=recruiter_id, region=region)
        .filter(Payroll.month < month)
        .filter(Payroll.start_date >= hire_date)
        .all()
    )
    return {
        "gross": sum(p.gross_pay or 0 for p in ytd_payrolls),
        "cpp": sum(p.cpp_amount or 0 for p in ytd_payrolls),
        "qpp": sum(p.qpp_amount or 0 for p in ytd_payrolls),
        "ei": sum(p.ei_amount or 0 for p in ytd_payrolls),
        "taxable_income": sum(p.gross_pay or 0 for p in ytd_payrolls),
    }


def calculate_work_hours(recruiter_id, start_date, end_date):
    shifts = ShiftLog.query.filter(
        ShiftLog.recruiter_id == recruiter_id,
        ShiftLog.clock_in >= start_date,
        ShiftLog.clock_out <= end_date
    ).all()

    worked_hours = sum(s.duration_hours or 0 for s in shifts)

    leaves = LeaveRequest.query.filter(
        LeaveRequest.recruiter_id == recruiter_id,
        LeaveRequest.start_date >= start_date,
        LeaveRequest.end_date <= end_date,
        LeaveRequest.status == "approved"
    ).all()

    paid_leave_hours = sum(l.override_hours or 0 for l in leaves if l.is_paid_leave)
    unpaid_leave_hours = sum(l.override_hours or 0 for l in leaves if not l.is_paid_leave)

    total_hours = worked_hours + paid_leave_hours - unpaid_leave_hours

    return total_hours, worked_hours, paid_leave_hours, unpaid_leave_hours


import holidays
from datetime import timedelta

def calculate_hours_and_holiday(region, province, start_date, end_date, rate, total_hours):
    # Treat MT and QC as 40-hour overtime threshold provinces
    overtime_threshold = 40 if region == "us" or province in ["QC", "MB"] else 44

    regular_hours = min(total_hours, overtime_threshold)
    overtime_hours = max(0, total_hours - overtime_threshold)

    # Determine correct country code
    country_code = "CA" if region in ["ca", "qc"] else "US"
    try:
        hol = holidays.country_holidays(country_code, subdiv=province, years=[start_date.year])
    except Exception:
        hol = {}

    holiday_hours = 0
    holiday_pay = 0
    for day in (start_date + timedelta(days=n) for n in range((end_date - start_date).days + 1)):
        if day in hol:
            holiday_hours += 8
            holiday_pay += 8 * rate

    return regular_hours, overtime_hours, holiday_hours, holiday_pay

def calculate_gross_pay(
    regular_hours,
    overtime_hours,
    holiday_pay,
    vacation_percent,
    rate,
    bonuses,
    include_vacation=True  # new optional flag
):
    regular_pay = regular_hours * rate
    overtime_pay = overtime_hours * rate * 1.5
    vacation_pay = (regular_pay + overtime_pay + holiday_pay) * (vacation_percent / 100)

    gross = regular_pay + overtime_pay + holiday_pay
    if include_vacation:
        gross += vacation_pay

    gross += sum([
        float(bonuses.get(key, 0)) for key in
        ["commission", "bonus", "tip", "parental_insurance", "travel_allowance", "family_bonus", "tax_credit"]
    ])

    return gross, vacation_pay


def calculate_insurance_deductions(data):
    return sum([
        float(data.get(key, 0)) for key in
        ["medical_insurance", "dental_insurance", "life_insurance", "retirement_amount", "deduction"]
    ])


def calculate_deductions(gross, ytd, region, province, data, year, insurance_deductions):
    # Same logic as your previous function, split into federal, local, CPP/QPP, EI etc.
    # If you want, I can write the full ready function too!
    ...
    return {
        "taxable_income": taxable_income,
        "federal_tax_amount": federal_tax_amt,
        "provincial_tax_amount": local_tax_amt,
        "total_tax": total_tax,
        "cpp_amount": cpp_contrib,
        "qpp_amount": qpp_contrib,
        "ei_amount": ei_contrib,
        "fica_amount": fica_contrib,
        "medicare_amount": medicare_contrib,
        "rqap_amount": rqap_contrib,
        "total_deductions": total_deductions,
        "bpa_data": {
            "bpa_annual": BPA_ANNUAL,
            "bpa_remaining": bpa_remaining,
            "bpa_period": current_bpa
        }
    }


def build_payroll_response(
    regular_hours, overtime_hours, holiday_hours,
    regular_pay, overtime_pay, holiday_pay, vacation_pay,
    gross, taxable_income, deductions, net_pay, bpa_data
):
    return {
        "regular_hours": round(regular_hours, 2),
        "overtime_hours": round(overtime_hours, 2),
        "holiday_hours": round(holiday_hours, 2),
        "regular_pay": round(regular_pay, 2),
        "overtime_pay": round(overtime_pay, 2),
        "holiday_pay": round(holiday_pay, 2),
        "vacation_pay": round(vacation_pay, 2),
        "gross_pay": round(gross, 2),
        "taxable_income": round(taxable_income, 2),
        "federal_tax_amount": round(deductions["federal_tax_amount"], 2),
        "provincial_tax_amount": round(deductions["provincial_tax_amount"], 2),
        "cpp_amount": round(deductions["cpp_amount"], 2),
        "qpp_amount": round(deductions["qpp_amount"], 2),
        "ei_amount": round(deductions["ei_amount"], 2),
        "fica_amount": round(deductions["fica_amount"], 2),
        "medicare_amount": round(deductions["medicare_amount"], 2),
        "rqap_amount": round(deductions["rqap_amount"], 2),
        "total_deductions": round(deductions["total_deductions"], 2),
        "net_pay": round(net_pay, 2),
        "flags": bpa_data
    }


def calculate_deductions(gross, ytd, region, province, data, year, insurance_deductions):
    from app.models import TaxConfig

    BPA_ANNUAL = 15000.0
    CPP_CAP = 3754.45
    QPP_CAP = 4038.42
    EI_CAP = 1049.12
    SS_CAP = 168600.0

    # Step 1 - BPA Basic Personal Amount
    pay_frequency = data.get("pay_frequency", "biweekly").lower()
    bpa_divisor = {"weekly": 52, "biweekly": 26, "monthly": 12}.get(pay_frequency, 26)
    BPA_PERIOD = BPA_ANNUAL / bpa_divisor

    bpa_remaining = max(0, BPA_ANNUAL - ytd.get("taxable_income", 0))
    current_bpa = min(BPA_PERIOD, bpa_remaining)

    taxable_income = max(0, gross - current_bpa)

    # Step 2 - Tax configs
    federal_region_key = {
        "ca": "canada_federal",
        "qc": "quebec_federal",
        "us": "us_federal"
    }.get(region, "other")

    local_region_key = f"{province.lower()}_state" if region == "us" else province.lower()

    federal_cfg = TaxConfig.query.filter_by(year=year, region=federal_region_key).first()
    local_cfg = TaxConfig.query.filter_by(year=year, region=local_region_key).first()

    # Step 3 - Tax brackets
    def apply_brackets(income, brackets):
        tax = 0
        for b in sorted(brackets or [], key=lambda x: x.get("from", 0)):
            lo = float(b.get("from", 0))
            hi = float(b.get("to", float("inf")))
            rate = float(b.get("rate", 0))
            if income > lo:
                tax += (min(income, hi) - lo) * (rate / 100)
        return round(tax, 2)

    federal_tax_amt = apply_brackets(taxable_income, federal_cfg.brackets if federal_cfg else [])
    local_tax_amt = apply_brackets(taxable_income, local_cfg.brackets if local_cfg else [])

    # Step 4 - Contribution rates from TaxConfig (fallback defaults if missing)
    cpp_rate = getattr(local_cfg, "cpp_rate", 5.95)
    qpp_rate = getattr(local_cfg, "qpp_rate", 7.0)
    ei_rate = getattr(local_cfg, "ei_rate", 1.32)
    fica_rate = getattr(local_cfg, "fica_rate", 6.2)
    medicare_rate = getattr(local_cfg, "medicare_rate", 1.45)
    rqap_rate = getattr(local_cfg, "rqap_rate", 0.767)

    # Step 5 - Calculate contributions
    cpp_contrib = qpp_contrib = ei_contrib = fica_contrib = medicare_contrib = rqap_contrib = 0

    if region == "us":
        fica_contrib = min(gross, SS_CAP) * (fica_rate / 100)
        medicare_contrib = gross * (medicare_rate / 100)
    elif province == "QC":
        qpp_contrib = min(gross * (qpp_rate / 100), max(0, QPP_CAP - ytd.get("qpp", 0)))
        ei_contrib = min(gross * (ei_rate / 100), max(0, EI_CAP - ytd.get("ei", 0)))
        rqap_contrib = gross * (rqap_rate / 100)
    else:
        cpp_contrib = min(gross * (cpp_rate / 100), max(0, CPP_CAP - ytd.get("cpp", 0)))
        ei_contrib = min(gross * (ei_rate / 100), max(0, EI_CAP - ytd.get("ei", 0)))

    # Step 6 - Total deductions
    if region == "us":
        total_deductions = federal_tax_amt + local_tax_amt + fica_contrib + medicare_contrib + insurance_deductions
    elif province == "QC":
        total_deductions = federal_tax_amt + local_tax_amt + qpp_contrib + ei_contrib + rqap_contrib + insurance_deductions
    else:
        total_deductions = federal_tax_amt + local_tax_amt + cpp_contrib + ei_contrib + insurance_deductions

    return {
        "taxable_income": taxable_income,
        "federal_tax_amount": federal_tax_amt,
        "provincial_tax_amount": local_tax_amt,
        "total_tax": federal_tax_amt + local_tax_amt,
        "cpp_amount": cpp_contrib,
        "qpp_amount": qpp_contrib,
        "ei_amount": ei_contrib,
        "fica_amount": fica_contrib,
        "medicare_amount": medicare_contrib,
        "rqap_amount": rqap_contrib,
        "total_deductions": round(total_deductions, 2),
        "bpa_data": {
            "bpa_annual": BPA_ANNUAL,
            "bpa_remaining": bpa_remaining,
            "bpa_period": current_bpa
        }
    } 

#######################################
@main.route("/payroll/delete", methods=["DELETE"])
@jwt_required()
def delete_payroll_entry():
    from flask import request, jsonify
    from app import db
    from app.models import Payroll

    recruiter_id = request.args.get("recruiter_id")
    month        = request.args.get("month")
    region       = request.args.get("region")
    start_date   = request.args.get("start_date")
    end_date     = request.args.get("end_date")

    # Basic validation
    if not recruiter_id or not start_date or not end_date:
        return jsonify({"error": "Missing required parameters (recruiter_id, start_date, end_date)"}), 400

    try:
        # Query using string dates
        payroll = Payroll.query.filter_by(
            recruiter_id=recruiter_id,
            start_date=start_date,
            end_date=end_date
        )

        # Optional: apply extra filters if present
        if month:
            payroll = payroll.filter_by(month=month)
        if region:
            payroll = payroll.filter_by(region=region)

        deleted_count = payroll.delete()
        db.session.commit()

        if deleted_count:
            return jsonify({"message": f"üóëÔ∏è Deleted {deleted_count} payroll entr{'y' if deleted_count == 1 else 'ies'}."}), 200
        else:
            return jsonify({"warning": "No matching payroll entry found."}), 404

    except Exception as e:
        db.session.rollback()
        return jsonify({"error": "Failed to delete payroll entry.", "details": str(e)}), 500